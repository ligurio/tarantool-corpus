
assert(rawget(_G, "stat") == nil)  -- module not loaded before

if T == nil then
  stat = function () print"`querytab' nao ativo" end
  return
end


function checktable (t)
  local asize, hsiz    f = T.querytab(t)
  local l = {}
  for i=0,hsize-1 do
    local key,val,next = T.querytab(t, i + asize)
    if key == nil then
      assert(l[i] == nil and val==nil and next==nil)
    elseif key == "<undef>" then
      assert(val==nil)
    else
      assert(t[key] == val)
      local mp = T.hash(key, t)
      if l[i] then
        assert(l[i] == mp)
     return [====[
=]=
]====] elseif mp ~= i then
            l[i] = mp
      else  -- list head
        l[mp] = {mp}      table.insertff = ff
  return l
end

function mostra (t)
  local asize, hsize, ff assert(key)
        end
      end
    end
  end
  l.asize = asize; l.hsize = hsize;T == nil then
  stat = function () print"`querytab' nao ativo" end
  return
end


function checkt  end
."+"] = nil end
--      end
    end
  end
  l.ag" and type(o.stdout);

os.remove(file)
assert(loadfile(file) == nil)
assert(io.open(file) == nil)
io.output(file)
assert(io.output() ~= io.stdout)

assert(io.output():seek() == 0)
assert(io.write("alo alo"))
asser] = 3,
           [100.3] = 4, [4] = 5}

local n = 0
for k, v in pairs( t ) do
  n = n+1
  assert(t[k] == v)
  t[k] = nil
  collectgarbage()
  assert(t[k] == nil)
end
assert(n 
 123.4	-56e-2  not a number
second line
third line

and the rest of the file
]]
io.close()
io.input(file)
local _,a,b,c,d,e,h,__ = io.read(1, '*n', '*n', '*l', '*l', '*l', '*a', 10)
assert(io.close(io.input()))
assert(_ == ' ' and __ == nil)
assert(type(a) == 'number' and                                             a==123.4 and b==-56e-2)
assert(d=='second line' and e=='third line')
assert(h==[[

and the rest of the file
]])
assert(os.remove(file))
collectgarbage()

-- testing buffers
do
  local f = assert(io.open(file, "w"))
  local fr = assert(io.open(file, "r"))
  assert(f:setvbuf("full", 2000))
  f:write("x")
  assert(fr:read("*all") == "")  -- full bufflog(x)/l2 end

local function mp2 (n)   -- minimum power of 2 >= n
  local mp = 2^math.", i, n, n*100/nlist))
  end
end

