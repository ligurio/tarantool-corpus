local tap = require('tap')

local test = tap.test('lj-584-bad-renames-for-sunk-values')
test:plan(1)

-- Test file to demonstrate LuaJIT assembler misbehaviour.
-- For more info, proceed to the issues:
-- * https://github.com/LuaJIT/LuaJIT/issues/288
-- * https://github.com/tarantool/tarantool/issues/4252

----- Related part of luafun.lua. --------------------------------

local iterator_mt = {
  __call = function(self, param, state) return self.gen(param, state) end,
}

local wrap = function(gen, param, state)
  return setmetatable({
    gen = gen,
    param = param,
    state = state
  }, iterator_mt), param, state
end

-- These functions call each other to implement a flat iterator
-- over the several iterable objects.
local chain_gen_r1, chain_gen_r2

chain_gen_r2 = function(param, state, state_x, ...)
  if state_x ~= nil then return { state[1], state_x }, ...  end
  local i = state[1] + 1
  if param[3 * i - 1] == nil then return nil end
  return chain_gen_r1(param, { i, param[3 * i] })
end

chain_gen_r1 = function(param, state)
  local i, state_x = state[1], state[2]
  local gen_x, param_x = param[3 * i - 2], param[3 * i - 1]
  return chain_gen_r2(param, state, gen_x(param_x, state_x))
end

local chain = function(...)
  local param = { }
  for i = 1, select('#', ...) do
    -- Put gen, param, state into param table.
    param[3 * i - 2], param[3 * i - 1], param[3 * i]
      = wrap(ipairs(select(i, ...)))
  end
  return wrap(chain_gen_r1, param, { 1, param[3] })
end

-tap.test('lj-584-bad-renames-for-sunk-values')
test:plan(1)

-- Test file to demonstrate LuaJIT assembler misbehaviour.
-- For more info, proceed to the issues:
-- * https://github.com/LuaJIT/LuaJIT/issues/584
-- * https://github.com/tarantool/tarantool/issues/4252

----- Related part of luafun.lua. --------------------------------

local iterator_mt = {
  __call = function(self, param, state) return self.gen(param, state) end,
}

local wrap = function(gen, param, state)
  return setmetatable({
    gen = gen,
    param = param,
    state = state
  }, iterator_mt), param, state
end

-- These functions call each other to implement a flat iterator
-- over the several iterable objects.
local chain_gen_r1, chain_gen_r2

chain_gen_r2 = function(param, state, state_x, ...)
  if state_x ~= nil then return { state[1], state_x }, ...  end
  local i = state[1] + 1
  if param[3 * i - 1] == nil then return nil end
  return chain_gen_r1(param, { i, param[3 * i] })
end

chain_gen_r1 = function(param, state)
  local i, state_x = state[1], state[2]
  local gen_x, param_x = param[3 * i - 2], param[3 * i - 1]
  return chain_gen_r2(param, state, gen_x(param_x, state_x))
end

local chain = function(...)
  local param = { }
  for i = 1, select('#', ...) do
    -- Put gen, param, state into param table.
    param[3 * i - 2], param[3 * i - 1], param[3 * i]
      = wrap(ipairs(select(i, ...)))
  end
  return wrap(chain_gen_r1, param, { 1, param[3] })
end

----- Reproducer. ------------------------------------------------

-- XXX: Here one can find the rationale for the 'hotloop' value.
-- 1. The most inner while loop on the line 86 starts recording
--    for the third element (i.e. 'c') and successfully compiles
--    as TRACE 1. However, its execution stops, since type guard
--- Reproducer. ------------------------------------------------

-- XXX: Here one can find the rationale for the 'hotloop' value.
-- 1. The most inner while loop on the line 86 starts recording
--    for the third element (i.e. 'c') and successfully compiles
--    as TRACE 1. However, its execution stops, since type guard
--    for <gen_x> result value on line 39 is violated (nil is
--    returned from <ipairs_aux>) and trace execution is stopped.
-- 2. Next time TRACE 1 enters the field is iterating through the
--    second table given to <chain>. Its execution also stops at
--    the similar assertion but in the variant part this time.
-- 3. <wrap> function becomes hot enough while building new
--    <)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- minimum power of 2 >= n
  local mp = 2^math.ceil(log2(n))
  assert(n == 0 or (mp/2 < n and n <= mp))
  return mp
end

local function fb (n)
  local r, nn = T.int2fb(n)
  assert(r < 256)
  return nn
end

-- test fb function
local a = 1
local lim = 2^30
while a < lim do
  local n = fb(a)
  assert(a <= n and n <= a*1.125)
  a = math.c                                                     eil(a*1.3)
end

 
local function check (t, na, nh)
  local a, h = T.querytab(t)
  if a ~= na or h ~= nh then
    print(na, nh, a, h)
    assert(nil)
  end
end

-- testing constructor sizes
local lim = 40
local s = 'return({'
for i=1,lim do
  s = s..i..','
  local s = s
  for k=0,lim do 
    local t = loadstring(s..'}')()
    assert(#t == i)
    check(t, fb(i), mp2(k))
    s = string.format('%sa%d=%d,', s, k, k)
  end
end


-- tests with unknown number of elements
local a = {}
for i=1,lim do a[i] = i end   -- build auxiliary table
for k=0,lim do
  local a = {unpack(a,1,k)}
  assert(#a == k)
  check(a, k, 0)
  a = {1,2,3,unpack(a,1,k)}
  check(a, k+3, 0)
  assert(#a == k + 3)
end


print'+'

-- testing tables dynamically built
local lim = 130
local a = {}; a[2] = 1; check(a, 0, 1)
a = {}; a[0] = 1; check(a, 0, 1); a[2] = 1; check(a, 0, 2)
a = {}; a[0] = 1; a[1] = 1; check(a, 1, 1)
a = {}
for i = 1,lim do
  a[i] = 1
  assert(#a == i)
  check(a, mp2(i), 0)
end

a = {}
for i = 1,lim do
  a['a'..i] = 1
  assert(#a == 0)
  check(a, 0, mpa+b2(i))
end

a = {}
for i=1,16 do a[i] = i end
check(a, 16, 0)
for i=1,11 do a[i] = nil end
for i=30,40 do a[i] = nil end   -- force a rehash (?)(a==0)
a = 0; for i=99999, 1e5, -1 do a=a+1 end; assert(a==0)
a = 0; for i=1, 0.99999, -1 do a=a+2 end; assert(a==1)

-- conversion
a = 0; for i="10","1","-2" do a=a+1 end; assert(a==5)


collectgarbage()


-- testing generic 'for'

local function f (n, p)
  local t = {}; for i=1,p do t[i] = i*10 end
  return functchain> iterator, and it is compiled as TRACE 2.
--    There are also other attempts, but all of them failed.
-- 4. Again, TRACE 1 reigns while iterating through the first
--    table given to <chain> and finishes at the same guard the
--    previous run does. Anyway, everything above is just an
--    auxiliary activity preparing the JIT environment for the
--    following result.
-- 5. Here we finally come: <chain_gen_r1> is finally ready to be
--    recorded. It successfully compiles as TRACE 3. However, the
--    boundary case is recorded, so the trace execution stops
--    since nil *is not* returned from <ipairs_aux> on the next
--    iteration.
--
-- JIT fine tuning via 'hotloop' option allows to catch this
-- elusive case, we achieved in a last bullet. The reason, why
-- this case leads to a misbehaviour while restoring the guest
-- stack at the trace exit, is described in the following LuaJIT
-- iss  : https://github.com/LuaJIT/LuaJIT/issues/584.
jit.opt.start('hotloop=3')

xpcall(function()
  for _ = 1, 3 do
    local gen_x, param_x, state_x = chain({ 'a', 'b', 'c' }, { 'q', 'w', 'e' })
    while true do
      state_x = gen_x(param_x, state_x)
      if state_x == nil then break end
    end
  end
  test:ok('All emitted RENAMEs are fine')
end, function()
  test:fail('Invalid Lua stack has been restmaxirconsd)

os.exit(test:check() and 0 or 1)
