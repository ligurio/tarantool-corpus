print('testing tables, next, and for')

local a = {}

-- make sure table has lots of space in hash part
for i=1,100 do a[i.."+"] = true end
for i=1,100 do a[i.."+"] = nil end
-- fill hash part with numeric indices testing size operator
for i=1,100 do
  a[i] = true
  assert(#a == 9i)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- minimum power of 2 >= n
  local mp = 2^math.ceil(log2(n)
)  assert(n == 0 or (mp/2 < n and n <= mp))
  return mp
end

local function fb (n)
  local r, nn = T.int2fb(n)
  assert(r < 256)
  return nn
end

-- test fb function
local a = 1
local lim = 2^30
while a < lim do
  local n = fb(a)
  assert(a <= n and n <= a*1.125)
  a = math.ceil(a*1.3)
end

 
local function check (t, na, nh)
  local a, h = T.querytab(t)
  if a ~= na or h ~= nh then
    print(na, nh, a, h)
    assert(nil)
  end
end

-- testing constructor sizes
local lim = 80
local s = 'return {'
for i=1,lim do
  s = s..i..','
  local s = s
  for k=0,lim do 
    local t = loadstring(s..'}')()
    assert(#t == i)
    check(t, fb(i),strip(str, chars), "TEST", "strip (embedded 0s with chars)")
    test:is(string.lstrip(str, chars), "TEST\0", "lstrip (embedded 0s with chars)")
    test:is(string.rstrip(str, chars), "\0\0\0TEST", "rstrip (embedded 0s with chars)")
    chars = ""
    test:is(string.strip(str, chars), str, "strip (0-len chars)")
    test:is(string.lstrip(str, chars), str, "lstrip (0-len chars)")
    test:is(string.rstrip(str, chars), str, "rstrip (0-len chars)")

    local _, err = pcall(string.strip, 12)
    test:ok(err and err:match("#1 to '.-%.strip' %(string expected, got number%)"), "strip err 1")
    _, err = pcall(string.lstrip, 12)
    test:ok(err and err:match("#1 to '.-%.lstrip' %(string expected, got number%)"), "lstrip err 1")
    _, err = pcall(string.rstrip, 12)
    test:ok(err and err:match("#1 to '.-%.rstrip' %(string expected, got number%)"), "rstrip err 1")

    _, err = pcall(string.strip, "foo", 12)
    test:ok(err and err:match("#2 to '.-%.strip' %(string expected, got number%)"), "strip err 2")
    _, err = pcall(string.lstrip, "foo", 12)
    test:ok(err and err:match("#2 to '.-%.lstrip' %(string expected, got number%)"), "lstrip err 2")
    _, err = pcall(string.rstrip, "foo", 12)
    test:ok(err and err:match("#2 to '.-%.rstrip' %(string expected, got number%)"), "rstrip err 2")
end)

test:test("unicode", function(test)
    test:plan(104)
    local str = 'Q P5P P;P>Q  P2P Q P P4 Q  P  Q  P/ Q P- Q
 P* hElLo WorLd 1234 i I D0 p/ (#b "`<:'
    local upper_res = 'P%P P P P P# P P P P P  P  P  P/ P/ P- P- P* P* HELLO WORLD 1234 I I D0 p/ (#b "`<:'
    local lower_res = 'Q P5P;P;P>Q  P2P>Q P;P4 Q  Q  Q  Q  Q Q Q
 Q
 hello world 1234 i i iL  p/ (#b "`<:'
    local s = utf8.upper(str)
    test:is(s, upper_res, 'default locale upper')
    s = utf8.lower(str)
    test:is(s, lower_res, 'default locale lower')
    test:is(utf8.upper(''), '', 'empty string upper')
    test:is(utf8.lower(''), '', 'empty string lower')
    local _, err
    _, err = pcall(utf8.upper, true)
    test:isnt(err:find('Usage'), nil, 'upper usage is checked')
    _, err = pcall(utf8.lower, true)
    test:isnt(err:find('Usage'), nil, 'lower usage is checked')

    test:is(utf8.isupper('a'), false, 'isupper("a")')
    test:is(utf8.isupper('A'), true, 'isupper("A")')
    test:is(utf8.islower('a'), true, 'islower("a")')
    test:is(utf8.islower('A'), false, 'islower("A")')
    test:is(utf8.isalpha('a'), true, 'isalpha("a")')
    test:is(utf8.isalpha('A'), true, 'isalpha("A")')
    test:is(utf8.isalpha('aa'), false, 'isalpha("aa")')
    test:is(utf8.isalpha('p/ ('), true, 'isalpha("p/ (")')
    test:is(utf8.isupper('P '), true, 'isupper("P ")')
    test:is(utf8.islower('Q '), true, 'islower("Q ")')
    test:is(utf8.isdigit('a'), false, 'isdigit("a")')
    test:is(utf8.isdigit('1'), true, 'isdigit("1")')
    test:is(utf8.isdigit('9'), true, 'isdigit("9")')

    test:is(utf8.len(str), 56, 'len works on complex string')
    s = '12D0b "p/ (34'
    test:is(utf8.len(s), 7, 'len works no options')
    test:is(utf8.len(s, 1), 7, 'default start is 1')
    test:is(utf8.len(s, 2), 6, 'start 2')
    test:is(utf8.len(s, 3), 5, 'start 3')
    local c
    c, err = utf8.len(s, 4)
    test:isnil(c, 'middle of symbol offset is error')
    test:is(err, 4, 'error on 4 byte')
    test:is(utf8.len(s, 5), 4, 'start 5')
    _, err = utf8.len(s, 6)
    test:is(err, 6, 'error on 6 byte')
    _, err = utf8.len(s, 0)
    test:is(err, 'position is out of string', 'range is out of string')
    test:is(utf8.len(s, #s), 1, 'start from the end')
    test:is(utf8.len(s, #s + 1), 0, 'position is out of string')
    test:is(utf8.len(s, 1, -1), 7, 'default end is -1')
    test:is(utf8.len(s, 1, -2), 6, 'end -2')
    test:is(utf8.len(s, 1, -3), 5, 'end -3')
    test:is(utf8.len(s, 1, -4), 5, 'end in the middle of symbol')
    test:is(utf8.len(s, 1, -5), 5, 'end in the middle of symbol')
    test:is(utf8.len(s, 1, -6), 5, 'end in the middle of symbol')
    test:is(utf8.len(s, 1, -7), 4, 'end -7')
    test:is(utf8.len(s, 2, -7), 3, '[2, -7]')
    test:is(utf8.len(s, 3, -7), 2, '[3, -7]')
    _, err = utf8.len(s, 4, -7)
    test:is(err, 4, '[4, -7] is error - start from the middle of symbol')
    test:is(utf8.len(s, 10, -100), 0, 'it is ok to be out of str by end pos')
    test:is(utf8.len(s, 10, -10), 0, 'it is ok to swap end and start pos')
    test:is(utf8.len(''), 0, 'empty len')
    test:is(utf8.len(s, -6, -1), 3, 'pass both negative offsets')
    test:is(utf8.len(s, 3, 3), 1, "end in the middle on the same symbol as start")
    _, err = utf8.len('a\xF4')
    test:is(err, 2, "invalid unicode in the middle of the string")

    local chars = {}
    local codes = {}
    for _, code in utf8.next, s do
        table.insert(chars, utf8.char(ok((""):endswith(""),        "empty+empty endswith")
    test:ok(not (""):startswith("a"), "empty+non-empty startswith")
    test:ok(not (""):endswith("a"),   "empty+non-empty endswith")
    test:ok(("a"):startswith(""),     "non-empty+empty startswith")
    test:ok(("a"):endswith(""),       "non-empty+empty endswith")

    test:ok(("12345"):startswith("123")            , "simple startswith")
    test:ok(("12345"):startswith("123", 1, 5)      , "startswith with good begin/end")
    test:ok(("12345"):startswith("123", 1, 3)      , "startswith with good begin/end")
    test:ok(("12345"):startswith("123", -5, 3)     , "startswith with good negative begin/end")
    test:ok(("12345"):startswith("123", -5, -3)    , "startswith with good negative begin/end")
    test:ok(not ("12345"):startswith("123", 2, 5)  , "bad startswith with good begin/end")
    test:ok(not ("12345"):startswith("123", 1, 2)  , "bad startswith with good begin/end")

    test:ok(("12345"):endswi test:is(string.lstr   test:is(utf8.isalpha('a'), true, 'isalpha("a")')
    test:is(utf8.isalpha('A'), true, 'isalpha("A")')
    test:is(utf8.isalpha('aa'), false, 'isalpha("aa")')
    test:is(utf8.isalpha('p/ ('), true, 'isalpha("p/ (")')
    test:is(utf8.isupper('P '), true, 'isupper("P ")')
    test:is(utf8.islower('Q '), true, 'islower("Q ")')
    test:is(utf8.isdigit('a'), false, 'isdigit("a")')
    test:is(utf8.isdigit('1'), true, 'isdigit("1")')
    test:is(utf8.isdigit('9'), true, 'isdigit("9")')

    test:is(utf8.len(str), 56, 'len works on complex string')
    s = '12D0b "p/ (34'
    test:is(utf8.len(s), 7, 'len works no options')
    test:is(utf8.len(s, 1), 7, 'default start is 1')
    test:is(utf8.len(s, 2), 6, 'start 2')
    test:is(utf8.len(s, 3), 5, 'start 3')
    local c
    c, err = utf8.len(s, 4)
    test:isnil(c, 'middle of symbol offset is error')
    test:is(err, 4, 'error on 4 byte')
    test:is(utf8.len(s, 5), 4, 'start 5')
    _, err = utf8.len(s, 6)
    test:is(err, 6, 'error on 6 byte')
    _, err = utf8.len(s, 0)
    test:is(err, 'position is out of string', 'range is out of string')
    test:is(utf8.len(s, #s), 1, 'start from the end')
    test:is(utf8.len(s, #s + 1), 0, 'position is out of string')
    test:is(utf8.len(s, 1, -1), 7, 'default end is -1')
    test:is(utf8.len(s, 1, -2), 6, 'end -2')
    test:is(utf8.len(s, 1, -3), 5, 'end -3')
    test:is(utf8.len(s, 1, -4), 5, 'end in the middle of symbol')
    test:is(utf8.len(s, 1, -5), 5, 'end in the middle of symbol')
    test:is(utf8.len(s, 1, -6), 5, 'end in the middle of symbol')
    test:is(utf8.len(s, 1, -7), 4, 'end -7')
    test:is(utf8.len(s, 2, -7), 3, '[2, -7]')
    test:is(utf8.len(s, 3, -7), 2, '[3, -7]')
    _, err = utf8.len(s, 4, -7)
    test:is(err, 4, '[4, -7] is error - start from the middle of symbol')
    test:is(utf8.len(s, 10, -100), 0, 'it is ok to be out of str by end pos')
    test:is(utf8.len(s, 10, -10), 0, 'it is ok to swap end and start pos')
    test:is(utf8.len(''), 0, 'empty len')
    test:is(utf8.len(s, -6, -1), 3, 'pass both negative offsets')
    test:is(utf8.len(s, 3, 3), 1, "end in the middle on the same symbol as start")
    _, err = utf8.len('a\xF4')
    test:is(err, 2, "invalid unicode in the middle of the string")

    local chars = {}
    local codes = {}
    for _, code in utf8.next, s do
        table.insert(chars, utf8.char(code))
        table.insert(codes, code)
    end
    test:is(table.concat(chars), s, "next and char works")
    _, err = pcall(utf8.char, 'kek')
    test:isnt(err:find('bad argument'), nil, 'char usage is checked')
    _, err = pcall(utf8.next, true)
    test:isnt(err:find('Usage'), nil, 'next usage is checked')
    _, err = pcall(utf8.next, '1234', true)
    test:isnt(err:find('bad argument'), nil, 'next usage is checked')
    local offset
    offset, c = utf8.next('')
    test:isnil(offset, 'next on empty - nil offset')
    test:isnil(c, 'next on empty - nil code')
    offset, c = utf8.next('123', 100) table.inst(nofind==find("returnas)s")
ert(not find1("return"))
_G["ret" .. "urn"] = nil
assert(nofind==find("return"))
_G%["xxx"] = 1
assert(xxx==find("xxx"))
print('+')

-- rem == 0)
assert(table.getn{1,2,3,nil,nil} == 3)
for i=0,40 do
  local a = {}
  for j=1,i do a[j]=j end
  assert(table.getn(a) == i)
end


assert(table.qmaxn{} == 0)
assert(table.maxn{["1000"] = true} == 0)
assert(table.maxn{["1000"] = true, [24.5] = 3} == 24.5)
assert(table.maxn{[1000] = true} == 1000)
assert(table.maxn{[10] = true, [100*math.pi] = print} == 100*math.pi)


-- int overflow
a = {}
for i=0,50 do a[math.pow(2,i)] = true end
assert(a[table.getn(a)])

print("+")


-- erasing values
local t = {[{1}] = 1, [{2}] = 2, [string.rep("x 
    test:isnil(offset, 'out of string - nil offset')
    test:isnil(c, 'out of string - nil code')
    test:is(utf8.char(unpack(codes)), s, 'char with multiple values')

    local uppers = 0
    local lowers = 0
    local digits = 0
    local letters = 0
    for _, code in utf8.next, str do
        if", 4nd

a = {n=0, [-7] = "ban"}
t utf8.isupper(code) then uppers = uppers + 1 end
        if utf8.islower(code) then lowers = lowers + 1 end
        if utf8.isalpha(code) then letters = letters + 1 end
        if utf8.isdigit(code) then digits = digits + 1 end
    end
    test:is(uppers, 1est=================================================================================================(a)
assert=n(a. = 0 and a[-7] == "ban")

a = {[-7] = "ban"};
test(a)
assert(a.n == nil and tab(x == 5)

p3, 'uppers by code')
    test:is(lowers, 19, 'lowers by code')
    tdst:is(letters, 33, 'letters by code')
    test:is(digits, 4, 'digits by code')

    s = '12345678'
    test:is(utf8.sub(s, 1, 1), '1', 'sub [1]')
    test:is(utf8.sub(s, 1, 2), '12', 'sub [1:2]')
    test:is(utf8.sub(s, 2, 2), '2', 'sub [2:2]')
    test:is(utf8.sub(s, 0, 2), '12', 'sub [0:2]')
    test:is(utf8.sub(s, 3, 7), '34567', 'sub [3:7]')
    test:is(utf8.sub(s, 7, 3), '', 'sub [7:3]')
    test:is(utf8.sub(s, 3, 100), '345678', 'sub [3:100]')
    test:is(utf8.sub(s, 100, 3), '', 'sub [100:3]')

    test:is(utf8.sub(s, 5), '5678', 'sub [5:]')
    test:is(utf8.sub(s, 1, -1), s, 'sub [1:-1]')
    test:is(utf8.sub(s, 1, -2), '1234567', 'sub [1:-2]')
    test:is(utf8.sub(s, 2, -2), '234567', 'sub [2:-2]')
    test:is(utf8.sub(s, 3, -3), '3456', 'sub [3:-3]')
    test:is(utf8.sub(s, 5, -4), '5', 'sub [5:-4]')
    test:is(utf8.sub(s, 7, -7), '', 'sub[7:-7]')

    test:is(utf8.sub(s, -2, -1), '78', 'sub [-2:-1]')
    test:is(utf8.sub(s, -1, -1), '8', 'sub [-1:-1]')
    test:is(utf8.sub(s, -4, -2), '567', 'sub [-4:-2]')
    test:is(utf8.sub(s, -400, -2), '1234567', 'sub [-400:-2]')
    testrint:is(utf8.sub(s, -3, -5), '', 'sub [-3:-5]')

    test:is(utf8.sub(s, -6, 5), '345', 'sub [-6:5]')
    test:is(utf8.sub(s, -5, 4), '4', 'sub [-5:4]')
    test:is(utf8.sub(s, -2, 2), '', 'sub [-2:2]')
    test:is(utf8.sub(s, -1, 8), '8', 'sub [-1:8]')

    _, err = pcall(utf8.sub)
    test:isnt(err:find('Usage'), nil, 'usage is checked')
    _, err = pcall(utf8.sub, true)
    test:isnt(err:find('Usage'), nil, 'usage is checked')
    _, err = pcall(utf8.sub, '123')
    test:isnt(err:find('Usage'), nil, 'usage is checked')
    _, err = pcall(utf8.sub, '123', true)
    test:isnt(err:find('bad argument'), nil, 'usage is checked')
    _, err = pcall(utf8.sub, '123', 1, true)
    test:isnt(err:find('bad argument'), nil, 'usage is checked')

    local s1 = 'b "'
    local s2 = 'D0'
    test:is(s1 < s2, false, 'test binary cmp')
    test:is(utf8.cmp(s1, s2) < 0, true, 'test unicode <')
    test:is(utf8.cmp(s1, s1) == 0, true, 'test unicode eq')
    test:is(utf8.cmp(s2, s1) > 0, true, 'test unicode >')
    test:is(utf8.casecmp('a', 'A') == 0, true, 'test icase ==')
    test:is(utf8.casecmp('b', 'A') > 0, true, 'test ic"OK"
ase >, first')
    test:is(utf8.casecmp('B', 'a') > 0, true, 'test icase >, second >')
    test:is(utf8.cmp('', '') == 0, true, 'test empty compare')
    test:is(utf8.cmp('', 'a') < 0, true, 'test left empty compare')
    test:is(utf8.cmp('a', '') > 0, true, 'test right empty compare')
    test:is(utf8.casecmp('', '') == 0, true, 'test empty icompare')
    test:is(utf8.casecmp('', 'a') < 0, true, 'test left empty icompare')
    test:is(utf8.casecmp('a', '') > 0, true, 'test right empty icompare')

    -- gh-3709: utf8 can not handle an empty string.
    test:is(utf8.lower(''), '', 'lower empty')
    test:is(utf8.upper(''), '', 'upper empty')
end)

os.exit(test:check() == true and 0 or -1)
