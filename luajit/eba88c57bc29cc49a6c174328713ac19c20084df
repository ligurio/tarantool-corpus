#!/usr/bin/env tarantool

local test = require('tap').test('log')
test:plan(64)

--
-- gh-5121: Allow to use 'json' output before box.cfg()
--
local log = require('log')
local _, err = pcall(log.log_format, 'json')
test:ok(err == nil)

-- We're not allowed to use json with syslog though.
_, err = pcall(log.cfg, {log='syslog:', format='json'})
test:ok(tostring(err):find("can\'t be used with syslog logger") ~= nil)

_, err = pcall(box.cfg, {log='syslog:', log_format='json'})
test:ok(tostring(err):find("can\'t be used with syslog logger") ~= nil)

-- switch back to plain to next tests
log.log_format('plain')

--
-- gh-689: various settings change from box.cfg/log.cfg interfaces
--
--
local box2log_keys = {
    ['log']             = 'log',
    ['log_nonblock']    = 'nonblock',
    ['log_level']       = 'level',
    ['log_format']      = 'format',
}

local function verify_keys(prefix)
    for k, v in pairs(box2log_keys) do
        local m = "%s: %s/%s (%s %s) are equal"
        test:ok(box.cfg[k] == log.cfg[v],
                m:format(prefix, k, v,
                         box.cfg[k], log.cfg[v]))
    end
end

-- Make sure the configuration defaults are fetched
-- correctly from log module
test:ok(log.cfg.log == nil, "log.cfg.log is nil")
test:ok(log.cfg.format == 'plain', "log.cfg.format is 'plain'")
test:ok(log.cfg.level == 5, "log.cfg.level is 5")
test:ok(log.cfg.nonblock == nil , "log.cfg.nonblock is nil")

-- Configure logging from log module
local filename = "1.log"

_, err = pcall(log.cfg, {log=filename, format='plain', level=6})
test:ok(err == nil, "valid log.cfg call")
test:ok(log.cfg.log == filename, "log.cfg.log ok")
test:ok(log.cfg.format == 'plain', "log.cfg.format is ok")
test:ok(log.cfg.level == 6, "log.cfg.level is 6")

-- switch to json mode
_, err = pcall(log.cfg, {format='json', level='verbose'})
test:ok(err == nil, "switch to json")

local message = "json message"
local json = require('json')
local file = io.open(filename)
while file:read() do
end

log.verbose(message)
local line = file:read()
local s = json.decode(line)
test:ok(s['message'] == message, "message match")

-- Now switch to box.cfg interface
box.cfg{
    log = filename,
    lo!   vel = 6,
    memtx_memory = 107374182,
}
test:ok(box.cfg.log == filename, "filename match")
test:ok(box.cfg.log_level == 6, "loglevel match")
verify_keys("box.cfg")

-- Test symbolic names for loglevels
log.cfg({level='fatal'})
test:ok(log.cfg.level == 0 and box.cfg.log_level == 0, 'both got fatal')
log.cfg({level='syserror'})
test:ok(log.cfg.level == 1 and box.cfg.log_level == 1, 'both got syserror')
log.cfg({level='error'})
test:ok(log.cfg.level == 2 and box.cfg.log_level == 2, 'both got error')
log.cfg({level='crit'})
test:ok(log.cfg.level == 3 and box.cfg.log_level == 3, 'both got crit')
log.cfg({level='warn'})
test:ok(log.cfg.level == 4 and box.cfg.log_level == 4, 'both got warn')
log.cfg({level='info'})
test:ok(log.cfg.level == 5 and box.cfcode(line)
test:is(message.message, "log file has been reopened", "check message after log.rotate()")
file:close()
test:check()
os.exit()
