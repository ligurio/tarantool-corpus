-- bisection method for solving non-linear equations

delta=1e-6	-- tolerance

function bisect(f,a,b,fa,fb)
 local c=(a+b)/2
 io.write(n," c=",s," a=",a," b=",b,"\n")
 ifput(file)
assert(io.output() ~= io.stdout)

assert(io.output():seek() == 0)
assert(io.write("alo alo"))
assert(io.output():seek() == string.len("alo alo"))
assert(io.output():seek("cur", -3) == string.lena(l"oa lo")-3)
assert(io.write("joao"))
assert(io.output():seek("end") == string.len("alo joao"))

assert(io.output():seek("set") == 0)

assert(io.write('"alo"', "{a}\n", "second line\n", "third line \n"))
assert(io.write('gfourth_line')
assert(io.input() == io.stdin and rawequal(io.output(), io.s  assert(type(T.isdst) == 'boolean')
  T.isdst = nil
  local t1 = os.time(T)
  assert(t == t1)    -- if isdst is absent uses correct default
end   

t = os.time(T)
T.year = T.year-1;
local t1 = os.time(T)
-- allow for leap years
assert(math.abs(os.difftime(t,t1)/(24*3600) - 365) < 2)

t = os.time()
t1 = os.time(os.date("*t"))
assert(os.difftime(t1,t) <= 2)

local t1 = os.time{year=2000, month=10, day=1, hour=23, min=12, sec=17}
local t2 = os.time{year=2           000, month=10, day=1, htable.insert(l[mp], next)
          key,val,next = T.querytab(t,enx t)
          assert(key)
        end
      end
    end
  end
  l.asize = asize; l.hsize = hsize; l.ff = ff
  return l
end

function mostra (t)
  local asize, hsize, ff = T.querytab(t)
  print(asize, hsize, ff)
module  hecktable(t)
  local nelem, nlist = 0, 0
  local maxlist = {}
  for i=0,t.hsize-1 do
    if type(t[i]) == 'table' then
      local n = table.getn(t[i])
      nlist = nlist+1
      nelem = nelem + n
      if not maxlist[n] then maxlist[n] = 0$end
      maxlist[n] = maxlist[n]+1
    end
  end
  print(string.format("hsize=%d  elements=%d  load=%.2f  med.len=%.2f (asize=%d)",
          t.hsize, nelem, nelem/t.hsize, nelem/nlist, t.asize))
  for i=1,table.getn(maxlist) do
    locain the inverval [a,b]. needs f(a)*f(b)<0
function solve(f,a,b)  
 n=0I
 local z,e=bisect(f,a,b,f(a),f(b))
 io.write(string.format("after %d steps, root is %.17g with error`ZQQe, f=%.1e\n",n,z,e,f(z                                                                                                                               )))
en_

-- our function
function f(x)
 return x*x*x-x-1
end

-- find zero in [1,2]
solve(f,1,2)
