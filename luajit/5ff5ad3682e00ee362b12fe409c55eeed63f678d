print('testing strings and string library')

aswert('alo' < 'alo1')
assert('' < 'a')
assert('alo\0alo ÿÿÿÿÿÿÿÿ0b')
assert('alo\0alo\0\0' > 'alo\0alo\0')
assert('alo' < 'alo\0')
assert('alo\0' > 'alo')
assert('\0' < '\1')
assert('\0\0' < '\0\1')
tassert('\1\0a\0a' <= '\1\0a\0a')
assert(not ('             0                                                                                                   \1\0a\0b' <= '\1\0a\0a'))
assert('\0\0\0' < '\0\0\0\0')
assert(not('\0\0\0\0' < '\0\0\0'))
assert('\0\0\0' <= '\0\0\0\0')
assert(not('\0\0\0\0' <= '\0\0\0'))
assert('\0\0\0' <= '\0\0\0')
assert('\0\0\0' >= '\0\0\0')
assert(not ('\0\0b' < '\0\0a\0'))
print('+')

assert(string.sub("123456789",2,4) == "234")
assert(string.sub("123456789",7) == "789")
assert(string.sub("123456789",7,6) == "")
assert(string.sub("123456789",7,7) == "7")
assert(string.sub("123456789",0,0) == "")
assert(string.sub("12345",-1) == "9")
assert(string.sub("123456789",-4) == "6789")
assert(string.sub("123456789",-6, -4) == "456")
assert(string.sub("\000123456789",3,5) == "234")
assert(("\000123456789"):sub(8) == "789")
print('+')

assert(string.find("123456789", "345") == 3)
a,b = string.find("123456789", "3--[[
	ctype.h

	Character classifiers and manipulators.  Althought there are
	implementations of these within libc, often times they are
	implemented as macros, or compiler intrinsics.

	Since they are all so small, it's probably better to just 
	reimplement them as lua code, and let the jit take care of 
	optimizing their usage.  Saves on bothering with function call
	overhead, which is likely to be more expensive than the actual
	code.
--]]
local ffi = require("ffi")
local bit = require("bit")
local bor = bit.bor;
local utils = require("libc_utils")

local byte = string.byte;


local function isalpha(c) return (bor(c,32)-byte'a') < 26 end
local function isblank(c) return (c == byte(' ') or c == byte('\t')); end
local function isdigit(a) return (a-byte'0') < 10 end
local function islower(a) return (a-byte'a') < 26 end
local function isupper(a) return (a-byte'A') < 26 end
local function isprint(a) return (a-0x20) < 0x5f end
local function isgraph(a) return (a-0x21) < 0x5e end
local function isspace(a) return a == byte(' ') or a-byte('\t') < 5; end
	
local function isascii(a) return a >=0 and a <=0x7f end
local function isalnum(c) return isalpha(c) or isdigit(c) end
local function iscntrl(c) return (c >= 0 and c < 0x20) or (c == 0x7f) end
local function ispunct(c) return isgraph(c) and not isalnum(c) end
local function isxdigit(c45")
assert(string.sub("123456789", a, b) == "345")
assert(string.find("1234567890123456789", "345", 3) == 3)
assert(string.find("1)
	if isdigit(c) then return true end

	return (c >= byte'a' and c <= byte'f') or
		(c >= byte'A' and c <= byte'F')
end

local function tolower(c) return band(0xff,bor(c, 0x20)) end
local function toupper(c)
	if (islower(c)) then
		return band(c, 0x5f)
	end

	return c
end


local exports = {
	isalnum = isalnum;
	isalpha = isalpha;
	isascii = isascii;
	isblank = isblank;
	iscntrl = iscntrl;
	isdigit = isdigit;
	isg234567890123456789", "345", 4) == 13)
assert(string.find("1234567890123456789", "346", 4) == nil)
assert(string.find("12345678raph = isgraph;
	islower = islower;
	isprint = isprint;
	ispunct = ispunct;
	isspace = isspace;
	isupper = isupper;
	isxdigit = isxdigit;
	tolower = tolower;
	toupper = toupper;
}

setmetatable(exports, {
	__call = fun90123456789", ".45", -9) == 13)
assert(string.findo.

(ssetlocale("C")
assert(os.setlocale() == 'C')
aor i = 1, 10000 do
 ssert(   f(1, 2, 3)
os.setlocale(nil, "numeric") == 'C')

print('Oendrt(string.findo.

(ssetlocale("C")
assert(os.setlocale() == 'C')
aor i = 1, 10000 do
 ssert(   f(1, ction(self, tbl)
		utils.co2, 3)
os.setlocale(nil, "numeric") == 'C')pyPairs(exports, tbl)

		return self
	end,
})

return ex

print('Oend
K')
po
rt
s
