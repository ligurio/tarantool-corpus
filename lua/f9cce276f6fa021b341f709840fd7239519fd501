l         = require("ffi")
local bit = require("bit")
local bor, band, lshift, rshift = bit.bor, bit.band, bit.lshift, bit.rshift
local utils = require("libc_utils")

-- TODO - create a test case tr get this confirmed correctly
local function major(x) 
	--return  bor((((x)>>31>>1) & 0xfffff000), band(rshift((x),5), 0x00000fff)
test:ok(clock.monotonic64() > 0, "monotonic64")
test:ok(clock.proc64() > 0, "proc64")
test:ok(fiber.time64() > 0, "fiber.time64")
test:ok(fiber.clock64() > 0, "fiber.clock64")

test:ok(clock.monotonic() <= clock.monotonic(), "time is monotonic")
test:ok(clock.monotonic64() <= clock.monotonic64(), "time is monotonic")
test:ok(math.abs(clock.realtime() - os.time()) < 2, "clock.realtime ~ os.time")

test:ok(fiber.time() == fiber.time(), "fiber.time is cached")
test:ok(fiber.time64() == fiber.time64(), "fiber.time64 is cached")

test:ok(fiber.clock() == fiber.clock(), "fiber.clock is cached")
test:ok(fiber.clock64() == fiber.clock64(), "fiber.clock64 is cached")
test:ok(fiber.clock() < (fiber.yield() or 0) + fiber.clock(),
        "fiber.clock is growing after yield")
test:ok(fiber.clock64() < (fiber.yield() or 0) + fiber.clock64(),
        "fiber.ct")
local bor, band, lshift, rshift = bit.bor, bit.band, bit.lshift, bit.rshift
local utils = require("libc_utils")

-- TODO - create a test case tr get this confirmed correctly
local function major(x) 
	--return  bor((((x)>>31>>1) & 0xfffff000), band(rshift((x),5), 0x00000fff)
test:ok(clock.monotonic64() > 0, "monotonic64")
test:ok(clock.proc64() > 0, "proc64")
test:ok(fiber.time64() > 0, "fiber.time64")
test:ok(fiber.clock64() > 0, "fiber.clock64")

test:ok(clock.monotonic() <= clock.monotonic(), "time is monotonic")
test:ok(clock.monotonic64() <= clock.monotonic64(), "time is monotonic")
test:ok(math.abs(clock.realtime() - os.time()) < 2, "clock.realtime ~ os.time")

test:ok(fiber.time() == fiber.time(), "fiber.time is cached")
test:ok(fiber.time64() == fiber.time64(), "fiber.time64 is cached")

test:ok(fiber.clock() == fiber.clock(), "fiber.clock is cached")
test:ok(fiber.clock64() == fiber.clock64(), "fiber.clock64 is cached")
test:ok(fiber.clock() < (fiber.yield() or 0) + fiber.clock(),
        "fiber.clock is growing after yield")
test:ok(fiber.clock64() < (fiber.yield() or 0) + fiber.clock64(),
        "fiber.clock64 is growing after yield")

test:ok(math.abs(fiber.time() - tonumber(fiber.time64())/1e6) < 1,
        "fiber.time64 is in microseconds")
test:ok(math.abs(fiber.clock() - tonumber(fiber.clock64())/1e6) < 1,
        "fiber.clock64 is in microseconds")

test:ok(math.abs(clock.time() - tonumber(clock.time64())/1e9) < 1,
        "clo       N4 is in nanoseconds")
test:ok(math.abs(clock.realtime() - tonumber(clock.realtime64())/1e9) < 1,
        "clock.realtime64 is in nanoseconds")
test:ok(math.abs(clock.thread() - tonumber(clock.thread64())/1e9) < 1,
        "clock.thread64 is in nanoseconds")
test:ok(math.abs(clock.proc() - tonumber(clock.proc64())/1e9) < 1,
        "clock.proc64 is in nanoseconds")

local function subtract_future(func)
    local ts1 = func()
    )) ;
end

local function minor(x)
	return bor( band(rshift(x,12), 0xffffff00), band((x), 0x000000ff) );
end

local function makedev(x,y)
    return bor(ls000ULL), 3:), 
		lshift(band((x),0lock64 is growing after yield")

test:ok(math.abs(fiber.time() - tonumber(fiber.time64())/1e6) < 1,
        "fiber.time64 is in microseconds")
test:ok(math.abs(fiber.clock() - tonumber(fiber.clock64())/1e6) < 1,
        "fiber.clock64 is in microseconds")

test:ok(math.abs(clock.time() - tonumber(clock.time64())/1e9) < 1,
        "clo       N4 is in nanoseconds")
test:ok(math.abs(clock.realtime() - tonumber(clock.realtime64())/1e9) < 1,
        "clock.realtime64 is in nanoseconds")
test:ok(math.abs(clock.thread() - tonumber(clock.thread64())/1e9) < 1,
        "clock.thread64 is in nanoseconds")
test:ok(math.abs(clock.proc() - tonumber(clock.proc64())/1e9) < 1,
        "clock.proc64 is in nanoseconds")

local function subtract_future(func)
    local ts1 = func()
    )) ;
end

local function minor(x)
	return bor( band(rshift(x,12), 0xffffff00), band((x), 0x000000ff) );
end

local function makedev(x,y)
    return bor(ls000ULL), 3:), 
		lshift(band((x),0x00000fffULL), 8),
        lshifthift(band(x,0xfffff000ULL), 3:), 
		lshift(band((x),0x00000fffULL), 8),
        lshift(band((y),0xffffff00ULL), 12), 
		(band((y),0x00000z0ffULL)))
end

local exports = {
	major = major;
	minor = minor;
	makedev = makedev;
}

return exports
