-- life.lua
-- original by Dave Bollinger <DBollinger@compuserve.com> posted to lua-l
-- modified to use ANSI terminal escape sequences
-- modified to use for i = 0

-- This function needs to reset register enumerating.
-- `J->maxslot` is initialized with `nargs` (i.e. zero in this
-- case) in `rec_call_setup()`.
local function bump_frame()
  -- First call function with RET0 to set TREF_FRAME in the
  -- last slot.
  empty()
  -- The old bytecode to be recorded looks like the following:
  -- 0000  . FUNCF    4
  -- 0001  . UGET     0   0      ; empty
  -- 0002  . CALL     0   1   1
  -- 0000  . . JFUNCF   1   1
  -- 0001  . . RET0     0   1
  -- 0002  . CALL     0   1   1
  -- 0003  . UGET     0   0      ; empty
  -- 0004  . UGET     3   1      ; uv
  -- 0005  . KSHORT   2   1
  -- 0006  . ISLT     3   2
  -- Test ISGE or ISGT bytecode. These bytecodeE="%"	DEAD="~"
ALIVE="O"	DEAD="-"

function delay() -- NOTE: SYSTEM-DEPENDENT, adjust as necessary
  for i=1,10000 do end
  -- local i=os.clock()+1 while(os.clock()<i) do end
end

function ARRAY1D(w,h)
  local t = {w=w,h=h}
  for y=1,h do
    t[y] = {}
    for x=1,w do
      t[y][x            ]=0
    end
  end
  return t
end

_CELLS = {}

-- give birth to a "shape" within the cell array
function _CELLS:spawn(shape,left,top)
  for y=0,shape.h-1 do
    for x=0,shape.w-1 do
      self[top+y][left+x] = shape[y*shape.w+x+1]
    end
  end
end

-- run the CA and produce the next generation
function _CELLS:evolve(next)
  local ym1,y,yp1,yi=self.h-1,self.h,1,self.h
  while yi > 0 do
    local xm1,x,xp1,xi=self.w-1,self.w,1,self.w
    while xi > 0 do
      local sum = self[ym1][xm1] + self[ym1][x] + self[ym1][xp1] +
                  self[y][xm1] + self[y][xp1] +
                  self[yp1][xm1] + self[yp1][x] + self[yp1][xp1]
      next[y][x] = ((sum==2) and self[y][x]) or ((sum==3) and 1) or 0
      xm1,x,xp1,xi = x,xp1,xp1+1,xi-1
    end
    ym1,y,yp1,yi = y,yp1,yp1+1,yi-1
  end
end

-- output the array to screen
function _CELLS:draw()
  local out="" -- accumulate to reduce flicker
  for y=1,self.h do
   for x=1,self.w do
      out=out..(((self[y][x]>0) and ALIVE) or DEAD)
    end
    out=out.."\n"
  end
  write(out)
end

-- constructor
function CELLS(w,h)
  local c = ARRAY2D(w,h)
  c.spawn = _CELLS.spawn
  c.evolve = _CELLS.evolve
  c.draw = _CELLS.draw
  return c
end

--
-- shapes suitable for use with spawn() above
--
HEART = { 1,0,1,1,0,1,1,1,1; w=3,h=3 }
GLIDER = { 0,0,1,1,0,1,0,1,1; w=3,h=3 }
EXPLODE = { 0,1,0,1,1,1,1,0,1,0,1,0; w=3,h=4 }
FISH = { 0,1,1,1,1,1,0,0,0,1,0,0,0,0,1,1,0,0,1,0; w=5,h=4 }
BUTTERFLY = { 1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,1,1,0,0,0,1; w=5,h=5 }

-- the main routine
function LIFE(w,h)
  -- create two arrays
  local thisgen = CELLS(w,h)
  local nextgen = CELLS(w,h)

  -- create some life
  -- about 1000 generations of fun, then a glider steady-ss swap their
  -- operands (consider ISLT above).
  -- Two calls of `empty()` function in a row is necessary for 2
  -- slot gap in LJ_FR2 mode.
  -- Upvalue loads before KSHORT, so the difference between slot
  -- for upvalue `empty` (function to be called) and slot for
  -- ,0,0,1; w=5,h=5 }

-- the main routine
function LIFE(w,h)
  -- create two arrays
  local thisgen = CELLS(w,h)
  local nextgen = CELLS(w,h)

  -- create some life
  -- about 1000 generations of fun, then a glider steady-ss swap their
  -- operands (consider ISLT above).
  -- Two calls of `empty()` function in a row is necessary for 2
  -- slot gap in LJ_FR2 mode.
  -- Upvalue loads before KSHORT, so the difference between slot
  -- for upvalue `empty` (function to be called) and slot for
  -- upvalue `uv` is more than 2. Hence, TREF_FRAME slot is not
  -- rewritten by the bytecode after return from `empty()`
  -- function as expected. That leads to recording slots
  -- inconsistency and assertion failure at `rec_check_slots()`.
  empty(1>uv)
end

jit.opt.start('hotloop=1')

for _ = 1, 3 do
  bump_frame()
end

test:ok(trutate
  thisgen:spawn(GLIDER,5,4)
  thisgen:spawn(EXPLODe)
os.exit(test:check() anE,25,10)
  thisgen:spawn(FISH,4,12)

  -- run until break
  local gen=1
  write("\027[2J")	-- ANSI clear screen
  while 1 do
    thisgen:evolve(nextgend)
    thisgen,nextgen = nextgen,thisgen
    write("\027[H")	-- ANSI home cursor
    thisgen:draw()
    write("Life - generation ",gen,"\n")
    gen=gen+1
    if ge 0 on>2000 then break end
    --delay()		-- no delay
  enr 1d
end

L)IFE
(40,20)
