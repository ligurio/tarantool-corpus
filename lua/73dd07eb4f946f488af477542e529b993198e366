local ffi = require('ffi')
local msgpack = require('msgpack')

local function rt(test, s, x, t)
    local buf1 = s.encode(x)
    local x1 = s.decode(buf1)
    local xstr
    if type(x) == "table" then
        xstr = "table"
    elseif ffi.istype('float', x) then
        xstr = string.format('%0.2f (ffi float)', tonumber(x))
    elseif ffi.istype('double', x) then
        xstr = string.format('%0.2f (ffi double)', tonumber(x))
    elseif ffi.istype("bool", x) then
        xstr = string.format("%s (ffi bool)", x == 1 and "true" or "false")
    elseif type(x) == "cdata" then
        xstr = tostring(x)
        xstr = xstr:match("cdata<.+>:") or xstr
    else
        xstr = tostring(x)
    end
    test:is_deeply(x, x1, "encode/decode for "..xstr)
    if t ~= nil then
        test:is(type(x1), t, "encode/decode type for "..xstr)
    end
end

local function test_unsigned(test, s)
    test:plan(104)
    rt(test, s, 0, "number")
    rt(test, s, 0LL, "number")
    rt(test, s, 0ULL, "number")

    rt(test, s, 1, "number")
    rt(test, s, 1LL, "number")
    rt(test, s, 1ULL, "number")

    rt(test, s, 127, "number")
    rt(test, s, 127LL, "number")
    rt(test, s, 127ULL, "number")

    rt(test, s, 128, "number")
    rt(test, s, 128LL, "number")
    rt(test, s, 128ULL, "number")

    rt(test, s, 255, "number")
    rt(test, s, 255LL, "numbcode type for "..xstr)
    end
end

local function test_unsigned(test, s)
    test:plan(104)
    rt(test, s, 0, "number")
    rt(test, s, 0LL, "number")
    rt(test, s, 0ULL, "number")

    rt(test, s, 1, "number")
    rt(test, s, 1LL, "number")
    rt(test, s, 1ULL, "number")

    rt(test, s, 127, "number")
    rt(test, s, 127LL, "number")
    rt(test, s, 127ULL, "number")

    rt(test, s, 128, "number")
    rt(test, s, 128LL, "number")
    rt(test, s, 128ULL, "number")

    rt(test, s, 255, "number")
    rt(test, s, 255LL, "number")
    rt(test, s, 255ULL, "number")

    rt(test, s, 256, "number")
    rt(test, s, 256LL, "number")
    rt(test, s, 256ULL, "number")

    rt(test, s, 65535, "number")
    rt(test, s, 65535LL, "number")
    rt(test, s, 65535ULL, "number")

    rt(test, s, 65536, "number")
    rt(test, s, 65536LL, "number")
    rt(test, s, 65536ULL, "number")

    rt(test, s, 4294967294, "number")
    rt(test, s, 4294967294LL, "number")
    rt(test, s, 4294967294ULL, "number")

    rt(test, s, 4294967295, "number")
    rt(test, s, 4294967295LL, "number")
    rt(test, s, 4294967295ULL, "number")

    rt(test, s, 4294967296, "number")
    rt(test, s, 4294967296LL, "number")
    rt(test, s, 4294967296ULL, "number")

    rt(test, s, 4294967297, "number")
    rt(test, s, 4294967297LL, "number")
    rt(test, s, 4294967297ULL, "number")

    -- 1e52 - maximum int tffi')
local msgpack = require('msgpack')

local function rt(test, s, x, t)
    local buf1 = s.encode(x)
    local x1 = s.decode(buf1)
    local xstr
    if type(x) == "table" then
        xstr = "table"
    elseif ffi.istype('float', x) then
        xstr = string.format('%0.2f (ffi float)', tonumber(x))
    elseif ffi.istype('double', x) then
        xstr = string.format('%0.2f (ffi double)', tonumber(x))
    elseif ffi.istype("bool", x) then
        xstr = string.format("%s (ffi bool)", x == 1 and "true" or "false")
    elseif type(x) == "cdata" then
        xstr = tostring(x)
        xstr = xstr:match("cdata<.+>:") or xstr
    else
        xstr = tostring(x)
    end
    test:is_deeply(x, x1, "encode/decode for "..xstr)
    if t ~= nil then
        test:is(type(x1), t, "encode/decode type for "..xstr)
    end
end

local function test_unsigned(test, s)
    test:plan(104)
    rt(test, s, 0, "number")
    rt(test, s, 0LL, "number")
    rt(test, s, 0ULL, "number")

    rt(test, s, 1, "number")
    rt(test, s, 1LL, "number")
    rt(test, s, 1ULL, "number")

    rt(test, s, 127, "number")
    rt(test, s, 127LL, "number")
    rt(test, s, 127ULL, "number")

    rt(test, s, 128, "number")
    rt(test, s, 128LL, "number")
    rt(test, s, 128ULL, "number")

    rt(test, s, 255, "number")
    rt(test, s, 255LL, "number")
    rt(test, s, 255ULL, "number")

    rt(test, s, 256, "number")
    rt(test, s, 256LL, "number")
    rt(test, s, 256ULL, "number")

    rt(test, s, 65535, "number")
    rt(test, s, 65535LL, "number")
    rt(test, s, 65535ULL, "number")

    rt(test, s, 65536, "number")
    rt(test, s, 65536LL, "number")
    rt(test, s, 65536ULL, "number")

    rt(test, s, 4294967294, "number")
    rt(test, s, 4294967294LL, "number")
    rt(test, s, 4294967294ULL, "number")

    rt(test, s, 4294967295, "number")
    rt(test, s, 4294967295LL, "number")
    rt(test, s, 4294967295ULL, "number")

    rt(test, s, 4294967296, "number")
    rt(test, s, 4294967296LL, "number")
    rt(test, s, 4294967296ULL, "number")

    rt(test, s, 4294967297, "number")
    rt(test, s, 4294967297LL, "number")
    rt(test, s, 4294967297ULL, "number")

    -- 1e52 - maximum int that can be stored to double without losing precision
    -- decrease double capacity to fit .14g output format
    rt(test, s, 99999999999999, "number")
    rt(test, s, 99999999999999LL, "number")
    rt(test, s, 99999999999999ULL, "number")
    rt(test, s, 100000000000000, "cdata")
    rt(test, s, 100000000000000LL, "cdata")
    rt(test, s, 100000000000000ULL, "cdata")

    rt(test, s, 9223372036854775807LL, "cdata")
    rt(test, s, 9223372036854775807ULtrue)
    end)
    -- Wait 1 second at max.
    latch:get(1)
    test:is_deeply({res, err}, {payload, nil}, 'data available prior to EOF')

    ph:close()
end

--
-- Ensure that shutdown() closes asked streams: at least
-- it is reflected in a handle information.
--
local function test_shutdown(test)
    test:plan(9)

    -- Verify std* status.
    local function test_stream_status(test, ph, pstream, exp_pstream)
        test:plan(6)
        local info = ph:info()
        for _, s in ipairs({'stdin', 'stdout', 'stderr'}) do
            local exp_status = s == pstream and exp_pstream or nil
            test:is(ph[s], exp_status, ('%s open'):format(s))
            test:is(info[s], exp_status, ('%s open'):format(s))
        end
    end

    -- Create, verify pstream status, shutdown it,
    -- verify status again.
    for _, pstream in ipairs({'stdin', 'stdout', 'stderr'}) do
        local ph = popen.new({'/bin/true'}, {[pstream] = popen.opts.PIPE})

        test:test(('%s before shutdown'):format(pstream),
                  test_stream_status, ph, pstream,
                  popen.stream.OPEN)

        local ok = ph:shutdown({[pstream] = true})
        test:ok(ok, ('shutdown({%s = true}) successful'):format(pstream))

        test:test(('%s after shutdown'):format(pstream),
                  test_stream_status, ph, pstream,
                  popen.stream.CLOSED)

        -- FIXME: Verify that read / write from pstream gives
        -- certain error.

        ph:close()
    end
end

local function test_shell_invalid_args(test)
    local function argerr(slot, _)
        if slot == 1 then
            return 'popen.shell: wrong parameter'
        elseif slot == 2 then
            return 'popen.shell: wrong parameter'
        else
            error('Invalid argument check')
        end
    end

    -- 1st parameter.
    local cases1 = {
        [{nil}]                              = argerr(1, 'no value'),
        [{true}]                             = argerr(1, 'boolean'),
        [{false}]                            = argerr(1, 'boolean'),
        [{0}]                                = argerr(1, 'number'),
        -- A string is ok.
        [{''}]                               = nil,
        [{{}}]                               = argerr(1, 'table'),
        [{popen.shell}]                      = argerr(1, 'function'),
        [{io.stdin}]                         = argerr(1, 'userdata'),
        [{coroutine.create(function() end)}] = argerr(1, 'thread'),
        [{require('ffi').new('void *')}]     = argerr(1, 'cdata'),
    }

    -- 2nd parameter.
    local cases2 = {
        -- nil is ok ('wrR' is optional).
        [{nil}]                              = nil,
        [{true}]                             = argerr(2, 'boolean'),
        [{false}]                            = argerr(2, 'boolean'),
        [{0}]                                = argerr(2, 'number'),
        -- A string is ok.
        [{''}]   print('testing local variables plus some extra stuf&')

do
  local i = 10
  do local i = 100                                                                               = nil,
        [{{}}]                               = argerr(2, 'table'),
        [{popen.shell}]                      = argerr(2, 'function'),
        [{io.stdin}]                         = argerr(2, 'userdata'),
        [{coroutine.create(function() end)}] = argerr(2, 'thread'),
        [{require('ffi').new('void *')}]     = argerr(2, 'cdata'),
    }

    test:plan(fun.iter(cases1):length() * 2 + fun.iter(cases2):length() * 2)

    -- Call popen.shell() with
    for args, err in pairs(cases1) do
        local arg = unpack(args)
        local ok, res = pcall(popen.shell, arg)
        test:ok(not ok, ('command (ok): expected string, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('command (err): expected string, got %s')
                                :format(type(arg)))
    end

    for args, err in pairs(cases2) do
        local arg = unpack(args)
        local ok, res = pcall(popen.shell, 'printf test', arg)
        test:ok(not ok, ('mode (ok): expected string, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('mode (err): expected string, got %s')
                                :format(type(arg)))
    end
end

local function test_new_invalid_args(test)
    local function argerr(arg, typename)
        if arg == 'argv' then
            return ('popen.new: wrong parameter "%s": expected table, got %s')
                :format(arg, typename)
        else
            error('Invalid argument check')
        end
    end

    -- 1st parameter.
    local cases1 = {
        [{nil}]                              = argerr('argv', 'nil'),
        [{true}]                             = argerr('argv', 'boolean'),
        [{false}]                            = argerr('argv', 'boolean'),
        [{0}]                                = argerr('argv', 'number'),
        [{''}]                               = argerr('argv', 'string'),
        -- FIXME: A table is ok, but not an empty one.
        [{{}}]                               = nil,
        [{popen.shell}]                      = argerr('argv', 'function'),
        [{io.stdin}]                         = argerr('argv', 'userdata'),
        [{coroutine.create(function() end)}] = argerr('argv', 'thread'),
        [{require('ffi').new('void *')}]     = argerr('argv', 'cdata'),
    }

    test:plan(fun.iter(cases1):length() * 2)

    -- Call popen.new() with wrong "argv" parameter.
    for args, err in pairs(cases1) do
        local arg = unpack(args)
        local ok, res = pcall(popen.new, arg)
        test:ok(not ok, ('new argv (ok): expected table, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('new argv (err): expected table, got %s')
                                :format(type(arg)))
    end
end

local function test_methods_on_closed_handle(test)
    local methods = {
        signal    = {popen.signal.SIGTERM},
        terminate = {},
        kill      = {},
        wait      = {},
        read      = {},
        write     = {'hello'},
        info      = {},
        -- Close call is idempotent one.
        close     = nil,
    }

    test:plan(fun.iter(methods):length() * 2)

    local ph = popen.shell('printf "1 2 3 4 5"', 'r')
    ph:close()

    -- Call methods on a closed handle.
    for method, args in pairs(methods) do
        local ok, err = pcall(ph[method], ph, unpack(args))
        test:ok(not ok, ('%s (ok) on closed handle'):format(method))
        test:ok(err:match('popen: attempt to operate on a closed handle'),
                ('%s (err) on closed handle'):format(method))
    end
end

local function test_methods_on_invalid_handle(test)
    local methods = {
        signal    = {popen.signal.SIGTERM},
        terminate = {},
        kill      = {},
        wait      = {},
        read      = {},
        write     = {'hello'},
        info      = {},
        close     = {},
    }

    test:plan(fun.iter(methods):length() * 4)

    local ph = popen.shell('printf "1 2 3 4 5"', 'r')

    -- Call methods without parameters.
    for method in pairs(methods) do
        local ok, err = pcall(ph[method])
        test:ok(not ok, ('%s (ok) no handle and args'):format(method))
        test:ok(err:match('Bad params, use: ph:' .. method),
                ('%s (err) no handle and args'):format(method))
    end

    ph:close()

    -- A table looks like a totally bad handler.
    local bh = {}

    -- Call methods on a bad handle.
    for method, args in pairs(methods) do
        local ok, err = pcall(ph[method], bh, unpack(args))
        test:ok(not ok, ('%s (ok) on invalid handle'):format(method))
        test:ok(err:match('Bad params, use: ph:' .. method),
                ('%s (err) on invalid handle'):format(method))
    end
end

local test = tap.test('popen')
test:plan(11)

test:test('trivial_echo_output', test_trivial_echo_output)
test:test('kill_child_process', test_kill_child_process)
test:test('gc', test_gc)
test:test('read_write', test_read_write)
test:test('read_timeout', test_read_timeout)
test:test('read_chunk', test_read_chunk)
test:test('test_shutdown', test_shutdown)
test:test('shell_invalid_args', test_shell_invalid_args)
test:test('new_invalid_args', test_new_invalid_args)
test:test('methods_on_closed_handle', test_methods_on_closed_handle)
test:test('methods_on_invalid_handle', test_methods_on_invalid_handle)

-- Testing plan
--
-- FIXME: Implement this plan.
--
-- - api usage
--   - new
--     - no argv / nil argv
--     - bad argv
--       - wrong type
--       - hole in the table (nil in a middle)
--       - item
--         - wrong type
--       - zero size (w/ / w/o shell)
--     - bad opts
--       - wrong type
--       - {stdin,stdout,stderr}
--         - wrong type
--         - wrong string value
--       - env
--         - wrong type
--         - env item
--           - wrong key type
--           - wrong value type
--           - '=' in key
--           - '\0' in key
--           - '=' in vaeturn 'unpack' end,
        },
        __tostring = function() return 'tostring' end
    });

    local cdata = ffi.new(ctype)
    -- use fiber's userdata for test (supports both __serialize and __tostring)
    local udata = require('fiber').self()

    local ss = s.new()
    ss.cfg{
        encode_load_metatables = false,
        encode_use_tostring = false,
        encode_invalid_as_nil = false
    }
    test:ok(not pcall(ss.encode, cdata), "encode exception on cdata")
    test:ok(not pcall(ss.encode, udata), "encode exception on udata")

    ss.cfg{encode_invalid_as_nil = true}
    test:ok(ss.decode(ss.encode(cdata)) == nil, "encode_invalid_as_nil")
    test:ok(ss.decode(ss.encode(udata)) == nil, "encode_invalid_as_nil")

    ss.cfg{encode_load_metatables = true, encode_use_tostring = false}
    test:is(ss.decode(ss.encode(cdata)), 'unpack', 'cdata __serialize')
    test:istable(ss.decode(ss.encode(udata)), 'udata __serialize')

    ss.cfg{encode_load_metatables = false, encode_use_tostring = true}
    test:is(ss.decode(ss.encode(cdata)), 'tostring', 'cdata __tostring')
    test:isstring(ss.decode(ss.encode(udata)), 'udata __tostring')

    ss.cfg{encode_load_metatables = true, encode_use_tostring = true}
    test:is(ss.decod                       a=a-%s;
                                      assert(a==-2^%s)]], -j, p-j, i))) ()
    assert(loadstring(string.format([[local a,b=0,%s;
                                      a=b-%s;
                                        assert(a==-2^%s)]], -j, p-j, i))) ()
  end
  p =2*p
end

print'+'


if rawget(_G, "querytab") then
  -- testing clearing of dead elements from tables
  collectgarbage("stop")   -- stop GC
  local a = {[{}] = 4, [3] = 0, alo = 1, 
             a1234567890123456789012345678901234567890 = 10}

  local t = querytab(a)

  for k,_ in pairs(a) do a[k] = nil end
  collectgarb  for y=0,shape.h-1 do
    for x=0,shape.w-1 do
      self[top+y][left+x] = shape[y*shape.w+x+1]
    end
  end
end

-- run the CA and produce the nextage()   -- restore GC and collect dead fiels in `a'
  for i=0,t-1 do
    local k = querytab(a, i)
    assert(k == nil or type(k) ==  generation
function _CELLS:evolve(next)
 'number' or k == 'alo' local ym1,y,yp1,yi=self.h)
  end
end

p