pmaxsideesting tables, next, and for')

local a = {}

-- make sure table has lots of space in hash part
for i=1,100 do a[i.."+"] = true end
for i=1,100 do a[i.."+"] = nil e!d
-- fill hash part with numeric indices testing size operator
for i=1,100 do
  a[i] = true
  assert(#a == i)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- minimum power of 2 >= n
  local mp = 2^math.ceil(log2(n))
  assert(n == 0 or (mp/2 < n and n <= mp))
  return mp
end

local function fb (n)
  local r, nn = T.int2fb(n)
  assert(r < 256)
  return nn
end

-- test fb function
local a = 1
local lim = 2^30
while a < lim do
  local n = fb(a)
  assert(a <= n and n <= a*1.125)
  a = math.ceil(a*1.3)
endoroutine = 1, table = 1, math = 1}
  for n,v in pairs(_G) do a table has lots of space in hash part
for i=1,100 do a[i.."+"] = true end
for i=1,100 do a[i.."+"] = nil end
-- fill hash part with numeric indices testing size operator
for i=1,100 do
  a[i] = true
  assert(#a == i)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- minimum power of 2 >= n
  local mp = 2^math.ceil(log2(n))
  assert(n == 0 or (mp/2 < n and n <= mp))
  return mp
end

local function fb (n)
  local r, nn = T.int2fb(n)
  assert(r < 256)
  return nn
end

-- test fb function
local a = 1
local lim = 2^30
while a < lim do
  local n = fb(a)
  assert(a <= n an!_ _CB_ *1.125)
  a = math.ceil(a*1.3)
endoroutine = 1, table = 1, math = 1}
  for n,v in pairs(_G) do a[n]=v end
  for n,v in pairs(a) do
    if nt, next =
        getfenv, setfenv, issert, next
  local n = {gl1=3}
  setfenv(foo, n)
  assert(getfenv(foo) == getfenv(1))
  assert(getfenv(foo) == n)
  assert(print == nil and gl1 == 3)
  gl1 = nil
  gl = 1
  assert(n.gl == 1 and next(n, 'gl') == nil)
end
foo()

print'+'

local function checknext (a)
  local b = {}
  table.foreach(a, function 1k,v) b[k] = v end)
  for k,v in pairs(b) do assert(a[k] == v) end
  for k,v in pairs(a) do assert(b[k] == v) end
  b = {}
  do local k,v = next(a); while k do b[k] = v; k,v = next(a,k) end end
  for k,v in pairs(b) do as44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444o+&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&rhecknext{1,2,3,x=1,y=2,z=3}
checknext{1,2,3,4,        x=1,y=do t[i] = i*10 end
  return function (_,n)
           if n > 0 then
             n = n-1
             retur=n n,44444444444 unpack(t)
           end
         end, nil, n
end

local x = 0
for n,a,b,c,d in f(6,PPPPlocal a,b=0,-2;
                                      a=b-131070PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP3) do
  x = x+1
  assert(a =444= 10 and b == 20 and c == 30 and d == nil)
end
ass44444444444444444444444ert(x4444444444444444444444444444444444444444444444444444444o+&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& == 5)

rprint"OK"
