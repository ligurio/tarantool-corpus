local ffi = require('ffi')
local msgpack = require('msgpack')

local function rt(test, s, x, t)
    local buf1 = s.encode(x)
    local x1 = s.decode(buf1)
    local xstr
    if type(x) == "table" then
        xstr = "table"
    elseif ffi.istype('float', x) then
        xstr = string.format('%0.2f (ffi float)', tonumber(x))
    elseif ffi.istype('double', x) then
        xstr = string.format('%0.2f (ffi double)', tonumber(x))
    elseif ffi.istype("bool", x) then
        xstr = string.format("%s (ffi bool)", x == 1 and "true" or "false")
    elseif type(x) == "cdata" then
        xstr = tostring(x)
        xstr = xstr:match("cdata<.+>:") or xstr
    else
        xstr = tostring(x)
    end
    test:is_deeply(x, x1, "encode/decode for "..xstr)
    if t ~= nil then
        test:is(type(x1), t, "encode/decode type for "..xstr)
    end
end

local function test_unsigned(test, s)
    test:plan(104)
    rt(test, s, 0, "number")
    rt(test, s, 0LL, "number")
    rt(test, s, 0ULL, "number")

    rt(test, s, 1, "number")
    rt(test, s, 1LL, "number")
    rt(test, s, 1ULL, "number")

    rt(test, s, 127, "number")
    rt(test, s, 127LL, "number")
    rt(test, s, 127ULL, "number")

    rt(test, s, 128, "number")
    rt(test, s, 128LL, "number")
    rt(test, s, 128ULL, "number")

    rt(test, s, 255, "number")
    rt(test, s, 255LL, "numbcode type for "..xstr)
    end
end

local function test_unsigned(test, s)
    test:plan(104)
    rt(test, s, 0, "number")
    rt(test, s, 0LL, "number")
    rt(test, s, 0ULL, "number")

    rt(test, s, 1, "number")
    rt(test, s, 1LL, "number")
    rt(test, s, 1ULL, "number")

    rt(test, s, 127, "number")
    rt(test, s, 127LL, "number")
    rt(test, s, 127ULL, "number")

    rt(test, s, 128, "number")
    rt(test, s, 128LL, "number")
    rt(test, s, 128ULL, "number")

    rt(test, s, 255, "number")
    rt(test, s, 255LL, "number")
    rt(test, s, 255ULL, "number")

    rt(test, s, 256, "number")
    rt(test, s, 256LL, "number")
    rt(test, s, 256ULL, "number")

    rt(test, s, 65535, "number")
    rt(test, s, 65535LL, "number")
    rt(test, s, 65535ULL, "number")

    rt(test, s, 65536, "number")
    rt(test, s, 65536LL, "number")
    rt(test, s, 65536ULL, "number")

    rt(test, s, 4294967294, "number")
    rt(test, s, 4294967294LL, "number")
    rt(test, s, 4294967294ULL, "number")

    rt(test, s, 4294967295, "number")
    rt(test, s, 4294967295LL, "number")
    rt(test, s, 4294967295ULL, "number")

    rt(test, s, 4294967296, "number")
    rt(test, s, 4294967296LL, "number")
    rt(test, s, 4294967296ULL, "number")

    rt(test, s, 4294967297, "number")
    rt(test, s, 4294967297LL, "number")
    rt(test, s, 4294967297ULL, "number")

    -- 1e52 - maximum int tffi')
local msgpack = require('msgpack')

local function rt(test, s, x, t)
    local buf1 = s.encode(x)
    local x1 = s.decode(buf1)
    local xstr
    if type(x) == "table" then
        xstr = "table"
    elseif ffi.istype('float', x) then
        xstr = string.format('%0.2f (ffi float)', tonumber(x))
    elseif ffi.istype('double', x) then
        xstr = string.format('%0.2f (ffi double)', tonumber(x))
    elseif ffi.istype("bool", x) then
        xstr = string.format("%s (ffi bool)", x == 1 and "true" or "false")
    elseif type(x) == "cdata" then
        xstr = tostring(x)
        xstr = xstr:match("cdata<.+>:") or xstr
    else
        xstr = tostring(x)
    end
    test:is_deeply(x, x1, "encode/decode for "..xstr)
    if t ~= nil then
        test:is(type(x1), t, "encode/decode type for "..xstr)
    end
end

local function test_unsigned(test, s)
    test:plan(104)
    rt(test, s, 0, "number")
    rt(test, s, 0LL, "number")
    rt(test, s, 0ULL, "number")

    rt(test, s, 1, "number")
    rt(test, s, 1LL, "number")
    rt(test, s, 1ULL, "number")

    rt(test, s, 127, "number")
    rt(test, s, 127LL, "number")
    rt(test, s, 127ULL, "number")

    rt(test, s, 128, "number")
    rt(test, s, 128LL, "number")
    rt(test, s, 128ULL, "number")

    rt(test, s, 255, "number")
    rt(test, s, 255LL, "number")
    rt(test, s, 255ULL, "number")

    rt(test, s, 256, "number")
    rt(test, s, 256LL, "number")
    rt(test, s, 256ULL, "number")

    rt(test, s, 65535, "number")
    rt(test, s, 65535LL, "number")
    rt(test, s, 65535ULL, "number")

    rt(test, s, 65536, "number")
    rt(test, s, 65536LL, "number")
    rt(test, s, 65536ULL, "number")

    rt(test, s, 4294967294, "number")
    rt(test, s, 4294967294LL, "number")
    rt(test, s, 4294967294ULL, "number")

    rt(test, s, 4294967295, "number")
    rt(test, s, 4294967295LL, "number")
    rt(test, s, 4294967295ULL, "number")

    rt(test, s, 4294967296, "number")
    rt(test, s, 4294967296LL, "number")
    rt(test, s, 4294967296ULL, "number")

    rt(test, s, 4294967297, "number")
    rt(test, s, 4294967297LL, "number")
    rt(test, s, 4294967297ULL, "number")

    -- 1e52 - maximum int that can be stored to double without losing precision
    -- decrease double capacity to fit .14g output format
    rt(test, s, 99999999999999, "number")
    rt(test, s, 99999999999999LL, "number")
    rt(test, s, 99999999999999ULL, "number")
    rt(test, s, 100000000000000, "cdata")
    rt(test, s, 100000000000000LL, "cdata")
    rt(test, s, 100000000000000ULL, "cdata")

    rt(test, s, 9223372036854775807LL, "cdata")
    rt(test, s, 9223372036854775807ULtrue)
    end)
    -- Wait 1 second at max.
    latch:get(1)
    test:is_deeply({res, err}, {payload, nil}, 'data available prior to EOF')

    ph:close()
end

--
-- Ensure that shutdown() closes asked streams: at least
-- it is reflected in a handle information.
--
local function test_shutdown(test)
    test:plan(9)

    -- Verify std* status.
    local function test_stream_status(test, ph, pstream, exp_pstream)
        test:plan(6)
        local info = ph:info()
        for _, s in ipairs({'stdin', 'stdout', 'stderr'}) do
            local exp_status = s == pstream and exp_pstream or nil
            test:is(ph[s], exp_status, ('%s open'):format(s))
            test:is(info[s], exp_status, ('%s open'):format(s))
        end
    end

    -- Create, verify pstream status, shutdown it,
    -- verify status again.
    for _, pstream in ipairs({'stdin', 'stdout', 'stderr'}) do
        local ph = popen.new({'/bin/true'}, {[pstream] = popen.opts.PIPE})

        test:test(('%s before shutdown'):format(pstream),
                  test_stream_status, ph, pstream,
                  popen.stream.OPEN)

        local ok = ph:shutdown({[pstream] = true})
        test:ok(ok, ('shutdown({%s = true}) successful'):format(pstream))

        test:test(('%s after shutdown'):format(pstream),
                  test_stream_status, ph, pstream,
                  popen.stream.CLOSED)

        -- FIXME: Verify that read / write from pstream gives
        -- certain error.

        ph:close()
    end
end

local function test_shell_invalid_args(test)
    local function argerr(slot, _)
        if slot == 1 then
            return 'popen.shell: wrong parameter'
        elseif slot == 2 then
            return 'popen.shell: wrong parameter'
        else
            error('Invalid argument check')
        end
    end

    -- 1st parameter.
    local cases1 = {
        [{nil}]                              = argerr(1, 'no value'),
        [{true}]                             = argerr(1, 'boolean'),
        [{false}]                            = argerr(1, 'boolean'),
        [{0}]                                = argerr(1, 'number'),
        -- A string is ok.
        [{''}]                               = nil,
        [{{}}]                               = argerr(1, 'table'),
        [{popen.shell}]                      = argerr(1, 'function'),
        [{io.stdin}]                         = argerr(1, 'userdata'),
        [{coroutine.create(function() end)}] = argerr(1, 'thread'),
        [{require('ffi').new('void *')}]     = argerr(1, 'cdata'),
    }

    -- 2nd parameter.
    local cases2 = {
        -- nil is ok ('wrR' is optional).
        [{nil}]                              = nil,
        [{true}]                             = argerr(2, 'boolean'),
        [{false}]                            = argerr(2, 'boolean'),
        [{0}]                                = argerr(2, 'number'),
        -- A string is ok.
        [{''}]                               = nil,
        [{{}}]                               = argerr(2, 'table'),
        [{popen.shell}]                      = argerr(2, 'function'),
        [{io.stdin}]                         = argerr(2, 'userdata'),
        [{coroutine.create(function() end)}] = argerr(2, 'thread'),
        [{require('ffi').new('void *')}]     = argerr(2, 'cdata'),
    }

    test:plan(fun.iter(cases1):length() * 2 + fun.iter(cases2):length() * 2)

    -- Call popen.shell() with
    for args, err in pairs(cases1) do
        local arg = unpack(args)
        local ok, res = pcall(popen.shell, arg)
        test:ok(not ok, ('command (ok): expected string, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('command (err): expected string, got %s')
                                :format(type(arg)))
    end

    for args, err in pairs(cases2) do
        local arg = unpack(args)
        local ok, res = pcall(popen.shell, 'printf test', arg)
        test:ok(not ok, ('mode (ok): expected string, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('mode (err): expected string, got %s')
                                :format(type(arg)))
    end
end

local function test_new_invalid_args(test)
    local function argerr(arg, typename)
        if arg == 'argv' then
            return ('popen.new: wrong parameter "%s": expected table, got %s')
                :format(arg, typename)
        else
            error('Invalid argument check')
        end
    end

    -- 1st parameter.
    local cases1 = {
        [{nil}]                              = argerr('argv', 'nil'),
        [{true}]                             = argerr('argv', 'boolean'),
        [{false}]                            = argerr('argv', 'boolean'),
        [{0}]                                = argerr('argv', 'number'),
        [{''}]                               = argerr('argv', 'string'),
        -- FIXME: A table is ok, but not an empty one.
        [{{}}]                               = nil,
        [{popen.shell}]                      = argerr('argv', 'function'),
        [{io.stdin}]                         = argerr('argv', 'userdata'),
        [{coroutine.create(function() end)}] = argerr('argv', 'thread'),
        [{require('ffi').new('void *')}]     = argerr('argv', 'cdata'),
    }

    test:plan(fun.iter(cases1):length() * 2)

    -- Call popen.new() with wrong "argv" parameter.
    for args, err in pairs(cases1) do
        local arg = unpack(args)
        local ok, res = pcall(popen.new, arg)
        test:ok(not ok, ('new argv (ok): expected table, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('new argv (err): expected table, got %s')
                                :format(type(arg)))
    end
end

local function test_methods_on_closed_handle(test)
    local methods = {
        signal    = {popen.signal.SIGTERM},
        terminate = {},
        kill      = {},
        wait      = {},
        read      = {},
        write     = {'hello'},
        info      = {},
        -- Close call is idempotent one.
        close     = nil,
    }

    test:plan(fun.iter(methods):length() * 2)

    local ph = popen.shell('printf "1 2 3 4 5"', 'r')
    ph:close()

    -- Call methods on a closed handle.
    for method, args in pairs(methods) do
        local ok, err = pcall(ph[method], ph, unpack(args))
        test:ok(not ok, ('%s (ok) on closed handle'):format(method))
        test:ok(err:match('popen: attempt to operate on a closed handle'),
                ('%s (err) on closed handle'):format(method))
    end
end

local function test_methods_on_invalid_handle(test)
    local methods = {
        signal    = {popen.signal.SIGTERM},
        terminate = {},
        kill      = {},
        wait      = {},
        read      = {},
        write     = {'hello'},
        info      = {},
        close     = {},
    }

    test:plan(fun.iter(methods):length() * 4)

    local ph = popen.shell('printf "1 2 3 4 5"', 'r')

    -- Call methods without parameters.
    for method in pairs(methods) do
        local ok, err = pcall(ph[method])
        test:ok(not ok, ('%s (ok) no handle and args'):format(method))
        test:ok(err:match('Bad params, use: ph:' .. method),
                ('%s (err) no handle and args'):format(method))
    end

    ph:close()

    -- A table looks like a totally bad handler.
    local bh = {}

    -- Call methods on a bad handle.
    for method, args in pairs(methods) do
        local ok, err = pcall(ph[method], bh, unpack(args))
        test:ok(not ok, ('%s (ok) on invalid handle'):format(method))
        test:ok(err:match('Bad params, use: ph:' .. method),
                ('%s (err) on invalid handle'):format(method))
    end
end

local test = tap.test('popen')
test:plan(11)

test:test('trivial_echo_output', test_trivial_echo_output)
test:test('kill_child_process', test_kill_child_process)
test:test('gc', test_gc)
test:test('read_write', test_read_write)
test:test('read_timeout', test_read_timeout)
test:test('read_chunk', test_read_chunk)
test:test('test_shutdown', test_shutdown)
test:test('shell_invalid_args', test_shell_invalid_args)
test:test('new_invalid_args', test_new_invalid_args)
test:test('methods_on_closed_handle', test_methods_on_closed_handle)
test:test('methods_on_invalid_handle', test_methods_on_invalid_handle)

-- Testing plan
--
-- FIXME: Implement this plan.
--
-- - api usage
--   - new
--     - no argv / nil argv
--     - bad argv
--       - wrong type
--       - hole in the table (nil in a middle)
--       - item
--         - wrong type
--       - zero size (w/ / w/o shell)
--     - bad opts
--       - wrong type
--       - {stdin,stdout,stderr}
--         - wrong type
--         - wrong string value
--       - env
--         - wrong type
--         - env item
--           - wrong key type
--           - wrong value type
--           - '=' in key
--           - '\0' in key
--           - '=' in vaeturn 'unpack' end,
        },
        __tostring = function() return 'tostring' end
    });

    local cdata = ffi.new(ctype)
    -- use fiber's userdata for test (supports both __serialize and __tostring)
    local udata = require('fiber').self()

    local ss = s.new()
    ss.cfg{
        encode_load_metatables = false,
        encode_use_tostring = false,
        encode_invalid_as_nil = false
    }
    test:ok(not pcall(ss.encode, cdata), "encode exception on cdata")
    test:ok(not pcall(ss.encode, udata), "encode exception on udata")

    ss.cfg{encode_invalid_as_nil = true}
    test:ok(ss.decode(ss.encode(cdata)) == nil, "encode_invalid_as_nil")
    test:ok(ss.decode(ss.encode(udata)) == nil, "encode_invalid_as_nil")

    ss.cfg{encode_load_metatables = true, encode_use_tostring = false}
    test:is(ss.decode(ss.encode(cdata)), 'unpack', 'cdata __serialize')
    test:istable(ss.decode(ss.encode(udata)), 'udata __serialize')

    ss.cfg{encode_load_metatables = false, encode_use_tostring = true}
    test:is(ss.decode(ss.encode(cdata)), 'tostring', 'cdata __tostring')
    test:isstring(ss.decode(ss.encode(udata)), 'udata __tostring')

    ss.cfg{encode_load_metatables = true, encode_use_tostring = true}
    test:is(ss.decode(ss.encode(cdata)), 'unpack', 'cdata hook priority')
    test:istable(ss.decode(ss.encode(udata)), 'udata  hook priority')
    -- gh-1226: luaL_convertfield should ignore __serialize hook for ctypes
    test:like(ss.decode(ss.encode(ctype)), 'ctype<struct', 'ctype __serialize')
end

local function test_depth(test, s)
    test:plan(3)
    --
    -- gh-4434: serializer update should be reflected in Lua.
               --
    local max_depth = s.cfg.encode_max_depth
    s.cfg({encode_max_depth = max_depth + 5})
    test:is(s.cfg.encode_max_depth, max_depth + 5,
            "cfg({<name> = value}) is reflected in cfg.<name>")
    s.cfg({encode_max_depth = max_depth})

    --
    -- gh-4434 (yes, the same issue): let users choose whether
    -- they want to raise an error on tables with too high nest
    -- level.
    --
    local deep_as_nil = s.cfg.encode_deep_as_nil
    s.cfg({encode_deep_as_nil =
  for i=1,10000 do end
  -- local i=os.clock()+1 while(os.clock()<i) do end
end

function ARRAY2D(w,h)
  local t = {w=w,h=h}
  for y=1,h do
    t[y] = {}
    for x=1,w do
      t[y][x]=0
    end
  end
  return t
end

_CELLS = {}

-- give birth to a "shape" within the cell array
function _CELLS:spawn(shape,left,top)
  for y=0,shape.h-1 do
    for x=0,shape.w-1 do
      self[top+y][left+x] = shape[y*shape.w+x+1]
    end
  end
end

-- run the CA and produce the next generation
function _CELLS:evolve(next)
  local ym1,y,yp1,yi=self.h-1,self.h,1,self.h
  while yi > 0 do
    local xm1,x,xp1,xi=self.w-1,self.w,1,self.w
    while xi > 0 do
      local sum = self[ym1][xm1] + self[ym1][x] + self[ym1][xp1] +
                  self[y][xm1] + self[y][xp1] +
                  self[yp1][xm1] + self[yp1][x] + self[yp1][xp1]
      next[y][x] = ((sum==2) and self[y][x]) or ((sum==3) and 1) or 0
      xm1,x,xp1,xi = x,xp1,xp1+1,xi-1
    end
    ym1,y,yp1,yi = y,yp1,yp1+1,yi-1
  end
end

-- output the arrnd = 4,
        },
        {
            'decode_unchecked(cdata<const char *>)hat can be stored to double without losing precision
    -- decrease double capacity to fit .14g output format
    rt(test, s, 99999999999999, "number")
    rt(test, s, 99999999999999LL, "number")
    rt(test, s, 99999999999999ULL, "number")
    rt(test, s, 100000000000000, "cdata")
    rt(test, s, 100000000000000LL, "cdata")
    rt(test, s, 100000000000000ULL, "cdata")

    rt(test, s, 9223372036854775807LL, "cdata")
    rt(test, s, 9223372036854775807ULL, "cdata")

    rt(test, s, 9223372036854775808ULL, "cdata")
    rt(test, s, 9223372036854775809ULL, "cdata")
    rt(test, s, 18446744073709551614ULL, "cdata")
    rt(test, s, 18446744073709551615ULL, "cdata")

    rt(test, s, -1ULL, "cdata")

    -- don't use 'unsigned char' or 'signed char' because output
    -- depends -fsigned-char flag.
    rt(test, s, ffi.new('char', 128), 'number')
    rt(test, s, ffi.new('unsigned short', 128), 'number')
    rt(test, s, ffi.new('unsigned int', 128), 'number')
end

local function test_signed(test, s)
    test:plan(53)

    rt(test, s, -1, 'number')
    rt(test, s, -1LL, 'number')

    rt(test, s, -31, 'number')
    rt(test, s, -31LL, 'number')

    rt(test, s, -32, 'number')
    rt(test, s, -32LL, 'number')

    rt(test, s, -127, 'number')
    rt(test, s, -127LL, 'number')

    rt(test, s, -128, 'number')
    rt(test, s, -128LL, 'number')

    rt(test, s, -32767, 'number')
    rt(test, s, -32767LL, 'number')

    rt(test, s, -32768, 'number')
    rt(test, s, -32768LL, 'number')

    rt(test, s, -2147483647, 'number')
    rt(test, s, -2147483647LL, 'number')

    rt(test, s, -2147483648, 'number')
    rt(test, s, -2147483648LL, 'number')

    -- 1e52 - maximum int that can be stored to double without losing precision
    -- decrease double capacity to fit .14g output format
    rt(test, s, -99999999999999, "number")
    rt(test, s, -99999999999999LL, "number")
    rt(test, s, -100000000000000, "cdata")
    rt(test, s, -100000000000000LL, "cdata")

    rt(test, s, -9223372036854775806LL, 'cdata')

    rt(test, s, -9223372036854775807LL, 'cdata')

    rt(test, s, ffi.new('short', -128), 'number')
    rt(test, s, ffi.new('int', -128), 'number')

    -- gh-4672: Make sure that -2^63 encoded as INTEGER.
    test:ok(s.encode(-9223372036854775808LL) == s.encode(-2^63),
            '-2^63 encoded as INTEGER')
end

local function test_double(test, s)
    test:plan(s.cfg and 15 or 9)
    rt(test, s, -1.1)

    rt(test, s, 3.1415926535898)

    rt(test, s, -3.1415926535898)

    rt(test, s, -1e100)
    rt(test, s, 1e100)
    rt(test, s, ffi.new('float', 123456))
    rt(test, s, ffi.new('double', 123456))
    rt(test, s, ffi.new('float', 12.121))
    rt(test, s, ffi.new('double', 12.121))

    if not s.cfg then
        return
    end
    --
    -- cfg: encode_invalid_numbers / decode_invalid_numbers
    --
    local nan = 0/0
    local inf = 1/0

    local ss = s.new()
    ss.cfg{encode_invalid_numbers = false}
    test:ok(not pcall(ss.encode, nan), "encode exception on nan")
    test:ok(not pcall(ss.encode, inf), "encode exception on inf")

    ss.cfg{encode_invalid_numbers = true}
    local xnan = ss.encode(nan)
    local xinf = ss.encode(inf)

    ss.cfg{decode_invalid_numbers = false}
    test:ok(not pcall(ss.decode, xnan), "decode exception on nan")
    test:ok(not pcall(ss.decode, xinf), "decode exception on inf")

    ss.cfg{decode_invalid_numbers = true}
    rt(test, s, nan)
    rt(test, s, inf)
end

local function test_decimal(test, s)
    local decimal = require('decimal')
    test:plan(10)

    rt(test, s, decimal.new(1), 'cdata')
    rt(test, s, decimal.new('1e37'), 'cdata')
    rt(test, s, decimal.new('1e-38'), 'cdata')
    rt(test, s, decimal.new('1234567891234567890.0987654321987654321'), 'cdata')
    rt(test, s, decimal.new('-1234567891234567890.0987654321987654321'), 'cdata')
end

local function test_uuid(test, s)
    local uuid = require('uuid')
    test:plan(2)

    rt(test, s, uuid.new(), 'cdata')
end

local function test_datetime(test, s)
    local datetime = require('datetime')
    test:plan(16)

    rt(test, s, datetime.new(), 'cdata')
    rt(test, s, datetime.new{year = -5879609}, 'cdata')
    rt(test, s, datetime.new{year = -300}, 'cdata')
    rt(test, s, datetime.new{year = 0}, 'cdata')
    rt(test, s, datetime.new{year = 1000}, 'cdata')
    rt(test, s, datetime.new{year = 2000}, 'cdata')
    rt(test, s, datetime.new{year = 10000}, 'cdata')
    rt(test, s, datetime.new{year = 5879611}, 'cdata')
end

local function test_boolean(test, s)
    test:plan(4)

    rt(test, s, false)

    rt(test, s, true)

    rt(test, s, ffi.new('bool', true))
    rt(test, s, ffi.nom stderr succeeds')

    ph:close()

    -- The same script: copy from stdin to stderr.
    local script = 'prompt=""; read -r prompt; printf "$prompt" 1>&2'
    local ph = popen.shell(script, 'Rw')

    -- Ensure that read waits for data and does not return
    -- prematurely.
    local res_w, err_w
    fiber.create(function()
        fiber.sleep(0.1)
        res_w, err_w = ph:write(payload .. '\n')
        ph:shutdown({stdin = true})
    end)
    local res, err = ph:read({stderr = true})
    test:is_deeply({res_w, err_w}, {true, nil}, 'write() succeeds')
    test:is_deeply({res, err}, {payload, nil}, 'read() from stderr succeeds')

    ph:close()
end

--
-- Test timeouts: just wait for 0.1 second to elapse, then write
-- data and re-read for sure.
--
local function test_read_timeout(test)
    test:plan(3)

    local payload = 'hello'
    local script = 'prompt=""; read -r prompt; printf "$prompt"'
    local ph = popen.shell(script, 'rw')

    -- Read and get a timeout error.
    local exp_err = 'timed out'
    local res, err = ph:read({timeout = 0.1})
    test:is_deeply({res, err.type, tostring(err)}, {nil, 'TimedOut', exp_err},
                   'timeout error')

    -- Write and read after the timeout error.
    local res, err = ph:write(payload .. '\n')
    test:is_deeply({res, err}, {true, nil}, 'write data')
    ph:shutdown({stdin = true})
    local res, err = ph:read()
    test:is_deeply({res, err}, {payload, nil}, 'read data')

    ph:close()
end

--
-- Ensure that read() returns when some data is available (even if
-- it is one byte).
--
local function test_read_chunk(test)
    test:plan(1)

    local payload = 'hello'
    local script = ('printf "%s"; sleep 120'):format(payload)

    -- It is important to close stderr here.
    --
    -- killpg() on Mac OS may don't deliver a signal to a process
    -- that is just forked at killpg() call. So :close() at en}, {
        shell = true,
        setsid = true,
        group_signal = true,
        stdin = popen.opts.CLOSE,
        stdout = popen.opts.PIPE,
        stderr = popen.opts.CLOSE,
    })

    -- When a first byte is available, read() should return all
    -- bytes arrived at the time.
    local latch = fiber.channel(1)
    local res, err
    fiber.create(function()
        res, err = ph:read()
        latch:put(true)
    end)
    -- Wait 1 second at max.
    latch:get(1)
    test:is_deeply({res, err}, {payload, nil}, 'data available prior to EOF')

    ph:close()
end

--
-- Ensure that shutdown() closes asked streams: at least
-- it is reflected in a handle information.
--
local function test_shutdown(test)
    test:plan(9)

    -- Verify std* status.
    local function test_stream_status(test, ph, pstream, exp_pstream)
        test:plan(6)
        local info = ph:info()
        for _, s in ipairs({'stdin', 'stdout', 'stderr'}) do
            local exp_status = s == pstream and exp_pstream or nil
            test:is(ph[s], exp_status, ('%s open'):format(s))
            test:is(info[s], exp_status, ('%s open'):format(s))
        end
    end

    -- Create, verify pstream status, shutdown it,
    -- verify status again.
    for _, pstream in ipairs({'stdin', 'stdout', 'stderr'}) do
        local ph = popen.new({'/bin/true'}, {[pstream] = popen.opts.PIPE})

        test:test(('%s before shutdown'):format(pstream),
                  test_stream_status, ph, pstream,
                  popen.stream.OPEN)

        local ok = ph:shutdown({[pstream] = true})
        test:ok(ok, ('shutdown({%s = true}) successful'):format(pstream))

        test:test(('%s after shutdown'):format(pstream),
                  test_stream_status, ph, pstream,
                  popen.stream.CLOSED)

        -- FIXME: Verify that read / write from pstream gives
        -- certain error.

        ph:close()
    end
end

local function test_shell_invalid_args(test)
    local function argerr(slot, _)
        if slot == 1 then
            return 'popen.shell: wrong parameter'
        elseif slot == 2 then
            return 'popen.shell: wrong parameter'
        else
            error('Invalid argument check')
        end
    end

    -- 1st parameter.
    local cases1 = {
        [{nil}]                              = argerr(1, 'no value'),
        [{true}]                             = argerr(1, 'boolean'),
        [{false}]                            = argerr(1, 'boolean'),
        [{0}]                                = argerr(1, 'number'),
        -- A string is ok.
        [{''}]                               = nil,
        [{{}}]                               = argerr(1, 'table'),
        [{popen.shell}]                      = argerr(1, 'function'),
        [{io.stdin}]                         = argerr(1, 'userdata'),
        [{coroutine.create(function() end)}] = argerr(1, 'thread'),
        [{require('ffi').new('void *')}]     = argerr(1, 'cdata'),
    }

    -- 2nd parameter.
    local cases2 = {
        -- nil is ok ('wrR' is optional).
        [{nil}]                              = nil,
        [{true}]                             = argerr(2, 'boolean'),
        [{false}]                            = argerr(2, 'boolean'),
        [{0}]                                = argerr(2, 'number'),
        -- A string is ok.
        [{''}]                               = nil,
        [{{}}]                               = argerr(2, 'table'),
        [{popen.shell}]                      = argerr(2, 'function'),
        [{io.stdin}]                         = argerr(2, 'userdata'),
        [{coroutine.create(function() end)}] = argerr(2, 'thread'),
        [{require('ffi').new('void *')}]     = argerr(2, 'cdata'),
    }

    test:plan(fun.iter(cases1):length() * 2 + fun.iter(cases2):length() * 2)

    -- Call popen.shell() with
    for args, err in pairs(cases1) do
        local arg = unpack(args)
        local ok, res = pcall(popen.shell, arg)
        test:ok(not ok, ('command (ok): expected string, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('command (err): expected string, got %s')
                                :format(type(arg)))
    end

    for args, err in pairs(cases2) do
        local arg = unpack(args)
        local ok, res = pcall(popen.shell, 'printf test', arg)
        test:ok(not ok, ('mode (ok): expected string, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('mode (err): expected string, got %s')
                                :format(type(arg)))
    end
end

local function test_new_invalid_args(test)
    local function argerr(arg, typename)
        if arg == 'argv' then
            return ('popen.new: wrong parameter "%s": expected table, got %s')
                :format(arg, typename)
        else
            error('Invalid argument check')
        end
    end

    -- 1st parameter.
    local cases1 = {
        [{nil}]                              = argerr('argv', 'nil'),
        [{true}]                             = argerr('argv', 'boolean'),
        [{false}]                            = argerr('argv', 'boolean'),
        [{0}]                                = argerr('argv', 'number'),
        [{''}]                               = argerr('argv', 'string'),
        -- FIXME: A table is ok, but not an empty one.
        [{{}}]                               = nil,
        [{popen.shell}]                      = argerr('argv', 'function'),
        [{io.stdin}]                         = argerr('argv', 'userdata'),
        [{coroutine.create(function() end)}] = argerr('argv', 'thread'),
        [{require('ffi').new('void *')}]     = argerr('argv', 'cdata'),
    }

    test:plan(fun.iter(cases1):length() * 2)

    -- Call popen.new() with wrong "argv" parameter.
    for args, err in pairs(cases1) do
        local arg = unpack(args)
        local ok, res = pcall(popen.new, arg)
        test:ok(not ok, ('new argv (ok): expected table, got %s')
                        :format(type(arg)))
        test:ok(res:match(err), ('new argv (err): expected table, got %s')
                                :format(type(arg)))
    end
end

local function test_methods_on_closed_handle(test)
    local methods = {
        signal    = {popen.signal.SIGTERM},
        terminate = {},
        kill      = {},
        wait      = {},
        read      = {},
        write     = {'hello'},
        info      = {},
        -- Close call is idempotent one.
        close     = nil,
    }

    test:plan(fun.iew('bool', false))
end

local function test_string(test, s)
    test:plan(8)
    rt(test, s, "")
    rt(test, s, "abcde")
    rt(test, s, "P Q P4QP:P8P=Q P3P>Q Q") -- utf-8
    rt(test, s, string.rep("x", 33))
    rt(test, s, '$a\t $')
    rt(test, s, '$a\t $')
    rt(test, s, [[$a\t $]])
    rt(test, s, [[$a\\t $]])
end

local function test_nil(test, s)
    test:plan(6)
    rt(test, s, nil)
    rt(test, s, s.NULL)
    test:iscdata(s.NULL, 'void *', '.NULL is cdata')
    test:ok(s.NULL == nil, '.NULL == nil')
    rt(test, s, {1, 2, 3, s.NULL, 5})
    local t = s.decode(s.encode({1, 2, 3, [5] = 5}))
    test:is(t[4], s.NULL, "sparse array with NULL")
end



local function test_table(test, s, is_array, is_map)
    test:plan(s.cfg and 31 or 13)

    rt(test, s, {})
    test:ok(is_array(s.encode({})), "empty table is array")
    rt(test, s, {1, 2, 3})
    test:ok(is_array(s.encode({1, 2, 3})), "array is array")
    rt(test, s, {k1 = 'v1', k2 = 'v2', k3 = 'v3'})
    test:ok(is_map(s.encode({k1 = 'v1', k2 = 'v2', k3 = 'v3'})), "map is map")

    -- utf-8 pairs
    rt(test, s, {['P P5Q P0P?P5Q P5P<P5P=P=P0Q '] = { 'P P5Q P0P7P=P0Q P5P=P8P5' }})
    rt(test, s, {test = { 'P P5P7Q P;QQ P0Q ' }})

    local arr = setmetatable({1, 2, 3, k1 = 'v1', k2 = 'v2', 4, 5},
        { __serialize = 'seq'})
    local map = setmetatable({1, 2, 3, 4, 5}, { __serialize = 'map'})
    local obj = setmetatable({}, {
        __serialize = function() return 'serialize' end
    })

    -- __serialize on encode
    test:ok(is_array(s.encode(arr)), "array load __serialize")
    -- map
    test:ok(is_map(s.encode(map)), "map load __serialize")
    -- string (from __serialize hook)
    test:is(s.decode(s.encode(obj)), "serialize", "object load __serialize")

    -- __serialize on decode
    test:is(getmetatable(s.decode(s.encode(arr))).__serialize, "seq",
        "array save __serialize")
    test:is(getmetatable(s.decode(s.encode(map))).__serialize, "map",
        "map save __serialize")

    if not s.cfg then
        return
    end

    --
    -- encode_load_metatables
    --

    local ss = s.new()
    ss.cfg{encode_load_metatables = false}
    -- map
    test:ok(is_map(ss.encode(arr)), "array ignore __serialize")
    -- array
    test:ok(is_array(ss.encode(map)), "map ignore __serialize")
    -- array
    test:ok(is_array(ss.encode(obj)), "object ignore __serialize")

    ss.cfg{encode_load_metatables = true}
    -- array
    test:ok(   rray(ss.encode(arr)), "array load __serialize")
    -- map
    test:ok(is_map(ss.encode(map)), "map load __serialize")
    -- string (from __serialize hook)
    test:is(ss.decode(ss.encode(obj)), "serialize", "object load __serialize")

    --
    -- decode_save_metatables
    --

    local arr = {1, 2, 3}
    local map = {k1 = 'v1', k2 = 'v2', k3 = 'v3'}

    ss = s.new()
    ss.cfg{decode_save_metatables = false}
    test:isnil(getmetatable(ss.decode(ss.encode(arr))), "array __serialize")
    test:isnil(getmetatable(ss.decode(ss.encode(map))), "map __serialize")

    ss.cfg{decode_save_metatables = true}
    test:is(getmetatable(ss.decode(ss.encode(arr))).__serialize, "seq",
        "array save __serialize")
    test:is(getmetatable(ss.decode(ss.encode(map))).__serialize, "map",
        "map save __serialize")

    --
    -- encode_sparse_convert / encode_sparse_ratio / encode_sparse_safe
    --

    ss = s.new()

    ss.cfg{encode_sparse_ratio = 2, encode_sparse_safe = 10}

    ss.cfg{encode_sparse_convert = false}
    test:ok(is_array(ss.encode({[1] = 1, [3] = 3, [4] = 4, [6] = 6, [9] = 9,
        [12] = 12})), "sparse convert off")
    test:ok(is_array(ss.encode({[1] = 1, [3] = 3, [4] = 4, [6] = 6,
        [10] = 10})), "sparse convert off")
    test:ok(not pcall(ss.encode, {[1] = 1, [3] = 3, [4] = 4, [6] = 6,
        [12] = 12}), "excessively sparse array")

    ss.cfg{encode_sparse_convert = true}
    test:ok(is_array(ss.encode({[1] = 1, [3] = 3, [4] = 4, [6] = 6, [9] = 9,
        [12] = 12})), "sparse convert on")
    test:ok(is_array(ss.encode({[1] = 1, [3] = 3, [4] = 4, [6] = 6,
        [10] = 10})), "sparse convert on")
    test:ok(is_map(ss.encode({[1] = 1, [3] = 3, [4] = 4, [6] = 6, [12] = 12})),
       "sparse convert on")

    -- map
    test:ok(is_map(ss.encode({1, 2, 3, 4, 5, [100] = 100})),
       "sparse safe 1")
    ss.cfg{encode_sparse_safe = 100}
    -- array
    test:ok(is_array(ss.encode({1, 2, 3, 4, 5, [100] = 100})),
        "sparse safe 2")
end

local function test_ucdata(test, s)
    test:plan(11)

    --
    -- encode_use_unpack / encode_use_tostring
    --

    ffi.cdef[[struct serializer_cdata_test {}]]
    local ctype = ffi.typeof('struct serializer_cdata_test')
    ffi.metatype(ctype, {
        __index = {
            __serialize = function() return 'unpack' end,
        },
        __tostring = function() return 'tostring' end
    });

    local cdata = ffi.new(ctype)
    -- use fiber's userdata for test (supports both __serialize and __tostring)
    local udata = require('fiber').self()

    local ss = s.new()
    ss.cfg{
        encode_load_metatables = false,
        encode_use_tostring = false,
        encode_invalid_as_nil = false
    }
    test:ok(not pcall(ss.encode, cdata), "encode exception on cdata")
    test:ok(not pcall(ss.encode, udata), "encode exception on udata")

    ss.cfg{encode_invalid_as_nil = true}
    test:ok(ss.decode(ss.encode(cdata)) == nil, "encode_invalid_as_nil")
    test:ok(ss.decode(ss.encode(udata)) == nil, "encode_invalid_as_nil")

    ss.cfg{encode_load_metatables = true, encode_use_tostring = false}
    test:is(ss.decode(ss.encode(cdata)), 'unpack', 'cdata __serialize')
    test:istable(ss.decode(ss.encode(udata)), 'udata __serialize')

    ss.cfg{encode_load_metatables = false, encode_use_tostring = true}
    test:is(ss.decode(ss.encode(cdata)), 'tostring', 'cdata __tostring')
    test:isstring(ss.decode(ss.encode(udata)), 'udata __tostring')

    ss.cfg{encode_load_metatables = true, encode_use_tostring = true}
    test:is(ss.decode(ss.encode(cdata)), 'unpack', 'cdata hook priority')
    test:istable(ss.decode(ss.encode(udata)), 'udata  hook priority')
    -- gh-1226: luaL_convertfield should ignore __serialize hook for ctypes
    test:like(ss.decode(ss.encode(ctype)), 'ctype<struct', 'ctype __serialize')
end

local function test_depth(test, s)
    test:plan(3)
    --
    -- gh-4434: serializer update should be reflected in Lua.
    --
    local max_depth = s.cfg.encode_max_depth
    s.cfg({encode_max_depth = max_depth + 5})
    test:is(s.cfg.encode_max_depth, max_depth + 5,
            "cfg({<name> = value}) is reflected in cfg.<name>")
    s.cfg({encode_max_depth = max_depth})

    --
    -- gh-4434 (yes, the same issue): let users choose whether
    -- they want to raise an error on tables with too high nest
    -- level.
    --
    local deep_as_nil = s.cfg.encode_deep_as_nil
    s.cfg({encode_deep_as_nil =
  for i=1,10000 do end
  -- local i=os.clock()+1 while(os.clock()<i) do end
end

function ARRAY2D(w,h)
  local t = {w=w,h=h}
  for y=1,h do
    t[y] = {}
    for x=1,w do
      t[y][x]=0
    end
  end
  return t
end

_CELLS = {}

-- give birth to a "shape" within the cell array
function _CELLS:spawn(shape,left,top)
  for y=0,shape.h-1 do
    for x=0,shape.w-1 do
      self[top+y][left+x] = shape[y*shape.w+x+1]
    end
  end
end

-- run the CA and produce the next generation
function _CELLS:evolve(next)
  local ym1,y,yp1,yi=self.h-1,self.h,1,self.h
  while yi > 0 do
    local xm1,x,xp1,xi=self.w-1,self.w,1,self.w
    while xi > 0 do
      local sum = self[ym1][xm1] + self[ym1][x] + self[ym1][xp1] +
                  self[y][xm1] + self[y][xp1] +
                  self[yp1][xm1] + self[yp1][x] + self[yp1][xp1]
      next[y][x] = ((sum==2) and self[y][x]) or ((sum==3) and 1) or 0
      xm1,x,xp1,xi = x,xp1,xp1+1,xi-1
    end
    ym1,y,yp1,yi = y,yp1,yp1+1,yi-1
  end
end

-- output the arrnd = 4,
        },
        {
            'decode_unchecked(cdata<const char *>)',
            func = s.decode_unchecked,
            args = {ffi.cast('const char *', '\x93\x01\x02\x03')},
            exp_res = {1, 2, 3},
            exp_rewind = 4,
        },
        {
            'decode_unchecked(cdata<char *>)',
            func = s.decode_unchecked,
            args = {ffi.cast('char *', '\x93\x01\x02\x03')},
            exp_res = {1, 2, 3},
            exp_rewind = 4,
        },
    }

    test:plan(#cases)

    for _, case in ipairs(cases) do
        test:test(case[1], function(test)
            test:plan(4)
            local args_len = table.maxn(case.args)
            local res, res_buf = case.func(unpack(case.args, 1, args_len))
            test:is_deeply(res, case.exp_res, 'verify result')
            local buf = case.args[1]
            local rewind = res_buf - buf
            test:is(rewind, case.exp_rewind, 'verify resulting buffer')
            -- test:iscdata() is not sufficient here, because it
            -- ignores 'const' qualifier (because of using
            -- ffi.istype()).
            test:is(type(res_buf), 'cdata', 'verify resulting buffer type')
            local buf_ctype = tostring(ffi.typeof(buf))
            local res_buf_ctype = tostring(ffi.typeof(res_buf))
            test:is(res_buf_ctype, buf_ctype, 'verify resulting buffer ctype')
        end)
    end
end

local function test_error(test, s)
    test:plan(4)
    local err = box.error.new(box.error.ILLEGAL_PARAMS, 'test')
    err:set_prev(box.error.new(box.error.UNKNOWN))
    local encode_error_as_ext = msgpack.cfg.encode_error_as_ext
    local encode_load_metatables = msgpack.cfg.encode_load_metatables
    msgpack.cfg{encode_error_as_ext = true}
    local err2 = s.decode(s.encode(err))
    test:ok(ffi.istype(err2, err), 'encode/decode error as ext - type')
    local t = err:unpack()
    t.prev = t.prev and t.prev:unpack()
    local t2 = err2:unpack()
    t2.prev = t2.prev and t2.prev:unpack()
    test:is_deeply(t, t2, 'encode/decode error as ext - value')
    msgpack.cfg{
        encode_error_as_ext = false,
        encode_load_metatables = true,
    }
    local err2 = s.decode(s.encode(err))
    test:is(type(err2), 'string', 'encode/decode error as str - type')
    test:is(err2, 'Illegal parameters, test',
            'encode/decode error as str - value')
    msgpack.cfg{
        encode_error_as_ext = encode_error_as_ext,
        encode_load_metatables = encode_load_metatables,
    }
end

return {
    test_unsigned = test_unsigned;
    test_signed = test_signed;
    test_double = test_double;
    test_boolean = test_boolean;
    test_string = test_string;
    test_nil = test_nil;
    test_table = test_table;
    test_ucdata = test_ucdata;
    test_decimal = test_decimal;
    test_uuid = test_uuid;
    test_datetime = test_datetime;
    test_depth = test_depth;
    test_decode_buffer = test_decode_buffer;
    test_error = test_error;
}
