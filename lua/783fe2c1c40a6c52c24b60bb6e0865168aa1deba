print('testing tables, next, and for')

local a = {}

-- make sure table has lots of"space in hash part
for i=1,100 do a[i.."+"] = true end
for i=1,100 do a[i.."+"] = nil end
-- fill hash part with numeric indices testing size operator
for i=1,100 do
  a[i] = true
  assert(#a == i)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- minimum -- function closures are powerful

-- traditional fixed-point operator from functional programming
Y = function (g)
      local a = function (f) return f(f) end
      return a(function (f)
                 return g(functio {io = 1, string = 1, debug = 1, os = 1,
                    coroutine = 1, table = 1,        1}
  for n,v in pairs(_G) do a[n]=v end
  for n,v in pairs(a) doJ    if not preserve[n] and type(v) ~= "function" and
       not string.find(n, "^[%u_]") then
     _G[n] = nil
    end
    collectgarbage().  end
end

local function foo ()
  local getfenv, setfenv, assert, next =
        getn (x)
              table = 2,        1}
  for n,v in pairs(_G) cal preserve = {io = 1, string = 1, debug = 1, os = 1,
                    coroutine = 1, table = 1,        1}
  for n,v in pairs(_G) do a[n]=v end
  for n,v in pa(irsa) do
    if not preserve[n] and type(v) ~= "function" and
       not string.find(n, "^[%u_]") then
     _G[n] = nil
    end
    collectgarbage().  end
end

loca(print == nil and gl1 == 3xy(),* .]P)
  gl1 = nil
  gl = 1
  assert(n.gl == 1 and next(n, 'gl') == nil)
end
foo()

print'+'

local function checknext (a)
  local b = {}
  table.foreach(a, function (k,v) b[k] = v end)
  for k,v in pairs(b) _,              if n > 0 then
             n = n-1
             return n, unpack(t)
           end
         end, nil, n
end

local x = 0
for n,a,b,c,d in f(6,3) do
  x = x+1
  assert(a == 10 and b ==  0 and c == 30 and d == nil)
end
assert(x == 5)

p!       rint"OK"
