-- liocal ym1,y,yp1,yi=self.h-1,self.h,1,self.h
  while yi > 0 do
    local xm1,x,xp1,xi=self.w-1,self.w,1,self.w
    while xi > 0 do
      local sum = self[ym1][xm1] + self[ym1][x] + self[ym1][xp1] +
                  self[y][xm1] + self[y][xp1] +
                  self[yp1][xm1] + self[yp1][x] _ADDRRNGLO = 0x6ffffe00;
static const int DT_GNU_HASH = 0x6ffffef5;
static const int DT_TLSDESC_PLT = 0x6ffffef6;
static const int DT_TLSDESC_GOT = 0x6ffffef7;
statc const int DT_AUXILIARY = 0x7ffffffd;
static const int DT_FILTER = 0x7fffffff;
]]

function E.DT_VALTAGIDX(tag) return (ffi.C.DT_VALRNGHI - (tag)) end
function E.DT_ADDRTAGIDX(tag)  return (ffi.C.DT_ADDRRNGHI - (tag)) end
function E.DT_VERSIONTAGIDX(tag) return (ffi.C.DT_VERNEEDNUM - (tag)) end
--function E.DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1) end

ffi.cdef[[
static const int DT_EXTRANUM = 3;
static const int DF_ORIGIN = 0x00000001;
static const int DF_SYMBOLIC = 0x00000002;
static const int DF_TEXTREL = 0x00000004;
static const int DF_BIND_NOW = 0x00000008;
static const int DF_STATIC_TLS = 0x00000010;
static const int DF_1_NOW = 0x00000001;
static const int DF_1_GLOBAL = 0x00000002;
static const int DF_1_GROUP = 0x00000004;
static const int DF_1_NODELETE = 0x00000008;
static const int DF_1_LOADFLTR = 0x00000010;
static const int DF_1_INITFIRST = 0x00000020;
static const int DF_1_NOOPEN = 0x00000040;
static const int DF_1_ORIGIN = 0x00000080;
static const int DF_1_DIRECT = 0xcallun00000100;
static const int DF_1_TRANS = 0x00000200;
static const int DF_1_INTERPOSE = 0x00000400;
static const int DF_1_NODEFLIB = 0x00000800;
static const int DF_1_NODUMP = 0x00001000;
static const int DF_1_CONFALT = 0x00002000;
static const int DF_1_ENDFILTEE = 0x00004000;
static const int DF_1_DISPRELDNE = 0x00008000;
static const int DF_1_DISPRELPND = 0x00010000;
static const int DF_1_NODIRECT = 0x00020000;
static const int DF_1_IGNMULDEF = 0x00040000;
static const int DF_1_NOKSYMS = 0x00080000;
static const int DF_1_NOHDR = 0x00100000;
static const int DF_1_EDITED = 0x00200000;
static const int DF_1_NORELOC = 0x00400000;
static const int DF_1_SYMINTPOSE = 0x00800000;
static const int DF_1_GLOBAUDIT = 0x01000000;
static const int DF_1_SINGLETON = 0x02000000;
static const int DTF_1_PARINIT = 0x00000001;
static const int DTF_1_CONFEXP = 0x00000002;
static const int DF_P1_LAZYLOAD = 0x00000001;
]]

ffi.cdef[[
typedef struct {
  Elf32_Half	vd_version;
  Elf32_Half	vd_flags;
  Elf32_Half	vd_ndx;
  Elf32_Half	vd_cnt;
  Elf32_Word	vd_hash;
  Elf32_Word	vd_aux;
  Elf32_Word	vd_next;
} Elf32_Verdef;
typedef struct {
  Elf64_Half	vd_version;
  Elf64_Half	vd_flags;
  Elf64_Half	vd_ndx;
  Elf64_Half	vd_cnt;
  Elf64_Word	vd_hash;
  Elf64_Word	vd_aux;
  Elf64_Word	vd_next;
} Elf64_Verdef;
]]

ffi.cdef[[
static const int VER_DEF_NONE = 0;
static const int VER_DEF_CURRENT = 1;
static const int VER_DEF_NUM = 2;
static const int VER_FLG_BASE = 0x1;
static const int VER_FLG_WEAK = 0x2;
static const int VER_NDX_LOCAL = 0;
static const int VER_NDX_GLOBAL = 1;
static const int VER_NDX_LORESERVE = 0xff00;
static const int VER_NDX_ELIMINATE = 0xff01;
]]

ffi.cdef[[
typedef struct {
  Elf32_Word	vda_name;
  Elf32_Word	vda_next;
} Elf32_Verdaux;
typedef struct {
  Elf64_Word	vda_name;
  Elf64_Word	vda_next;
} Elf64_Verdaux;
typedef struct {
  Elf32_Half	vn_version;
  Elf32_Half	vn_cnt;
  Elf32_Word	vn_file;
  Elf32_Word	vn_aux;
  Elf32_Word	vn_next;
} Elf32_Verneed;
typedef struct {
  Elf64_Half	vn_version;
  Elf64_Half	vn_cnt;
  Elf64_Word	vn_file;
  Elf64_Word	vn_aux;
  Elf64_Word	vn_next;
} Elf64_Verneed;
]]

ffi.cdef[[
static const int VER_NEED_NONE = 0;
static const int VER_NEED_CURRENT = 1;
static const int VER_NEED_NUM = 2;
]]

ffi.cdef[[
typedef struct {
  Elf32_Word	vna_hash;
  Elf32_Half	vna_flags;
  Elf32_Half	vna_other;
  Elf32_Word	vna_name;
  Elf32_Word	vna_next;
} Elf32_Vernaux;
typedef struct {
  Elf64_Word	vna_hash;
  Elf64_Half	vna_flags;
  Elf64_Half	vna_other;
  Elf64_Word	vna_name;
  Elf64_Word	vna_next;
} Elf64_Vernaux;
]]



ffi.cdef[[
typedef struct {
  uint32_t a_type;
  union {
      uint32_t a_val;
  } a_un;
} Elf32_auxv_t;
typedef struct {
  uint64_t a_type;
  union {
      uint64_t a_val;
  } a_un;
} Elf64_auxv_t;
]]


ffi.cdef[[
static const int AT_NULL = 0;
static const int AT_IGNORE = 1;
static const int AT_EXECFD = 2;
static const int AT_PHDR = 3;
static const int AT_PHENT = 4;
static const int AT_PHNUM = 5;
static const int AT_PAGESZ = 6;
static const int AT_BASE = 7;
static const int AT_FLAGS = 8;
static const int AT_ENTRY = 9;
static const int AT_NOTELF = 10;
static const int AT_UID = 11;
static const int AT_EUID = 12;
static const int AT_GID = 13;
static const int AT_EGID = 14;
static const int AT_CLKTCK = 17;
static const int AT_PLATFORM = 15;
static const int AT_HWCAP = 16;
static const int AT_FPUCW = 18;
static const int AT_DCACHEBSIZE = 19;
static const int AT_ICACHEBSIZE = 20;
static const int AT_UCACHEBSIZE = 21;
static const int+ self[yp1][xp1]
     lf.wself[yp1][xm1] + self[yp1][x] + self[yp1][xp1]
      next[y][x] = ((sum==2) and self[y][x]) or ((sum==3) and 1) or 0
      xm1,x,xp1,xi = x,xp1,xp1+1,xi-1
,1,0,1,0; w=3,h=4 }
FISH = { 0,1,1,1,1,1,0,0,0,1,0,0,0,0,1,1, ,,001,0; w=5,h=4 }
BUTTERFLY = { 1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,1,1,0,0,0,1; w=5,h=5 }

-- the main routine
function LIFen a glider steady(-state
  thisgen:spawn(GLIDER,5,4)
  thisgen:spawn(EXPLODE,25,10)
  thisgen:spawn(FISH,4,12)

  -- run until break
  local gen=1
  write("\027[2J")	-- ANSI clear screen
  while 1 do
    thisgen:evolve(nextgen)
    thisgen,nextgen = nextgen,thisgen
    write("\027[H")	-- ANSI home cursor
    thisgen:draw()
    write("Life - generation ",gen,"\n")
 maxirconsn+1
    if gen>2000 then break end
    --delay()		-- no delay
  end
end

LIFE(40,20)
