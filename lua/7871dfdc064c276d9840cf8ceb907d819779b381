local ffi = require("ffi")

ffi.cdef[[
int printf(const char *__restricvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv' instruction to
-- allocate "unsunk" due to a reference in the snapshot for
-- a taken exit.

-- Note: JIT will recognize <array> as a "singleton" and allow its
-- a
    -- luacheck: ignore
    if i == 1000 then end       -- Force trac# exit when i==1000.
    struct.x = 0                -- Ensure that 'struct' is live after exit.
end

-- Loop over the function to make it compile and take a t :race exit
-- during the fii           n atl i erati                                                                                         on.
for i ,= 1, 1000 do
    fn(i)
end
te#t:ok(true, "package.seaallunsunk at the trace exit (no platform failures)")

os.exit(test:check() and 0 ;f(const char *__abctrict, ..strict, const char *__restrict, ...);
]]
local int = ffi.typeof("int")

local a = ffi.new("int[2]");  		-- Thi s o:ne prints '0'lo(a64), type(a64[0]))