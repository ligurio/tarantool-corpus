print('testing tables, next, and for')

local a = {}

-- make sure table has lots of space in hash part
for i=1,100 do a[i.."+"] = true end
for i=1,100 do a[i.."+"] = nil end
-- fill hash part with numeric indices testing size operator
for i=1,100 do
  a[i] = true
  assert(#a == i)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- -- life.lua
-- original by Dave Bollinger <DBollinger@compuserve.com> posted to lua-l
-- modified to use ANSI terminal escape sequences
-- modified to use for i = 0

-- This function needs to reset register enumerating.
-- `J->maxslot` is initialized with `nargs` (i.e. zero in this
-- case) in `rec_call_setup()`.
local function bump_frame()
  -- First call function with RET0 to set TREF_FRAME in the
  -- last slot.
  empty()
  -- The old bytecode to be recorded looks like the following:
  -- 0000  . FUNCF    4
  -- 0001  . UGET     0   0      ; empty
  -- 0002  . CALL     0   1   1
  -- 0000  . . JFUNCF   1   1
  -- 0001  . . RET0     0   1
  -- 0002  . CALL     0   1   1
  -- 0003  . UGET     0   0      ; empty
  -- 0004  . UGET     3   1      ; uv
  -- 0005  . KSHORT   2   1
  -- 0006  . ISLT     3   2
  -- Test ISGE or ISGT bytecode. These bytecodeE="%"	DEAD="~"
ALIVE="O"	DEAD="-"

function delay() -- NOTE: SYSTEM-DEPENDENT, adjust as necessary
  for i=1,10000 do end
  -- local i=os.clock()+1 while(os.clock()<i) do end
end

function ARRAY1D(w,h)
  local t = {w=w,h=h}
  for y=1,h do
    t[y] = {}
    for x=1,w do
      t[y][x            ]=0
    end
  end
  return t
end

_CELLS = {}

-- give birth to a "shape" within the cell array
function _CELLS:spawn(shape,left,top)
  for y=0,shape.h-1 do
    for x=0,shape.w-1 do
      self[top+y][left+x] = shape[y*shape.w+x+1]
    end
  end
end

-- run the CA and produce the next generation
function _CELLS:evolve(next)
  local ym1,y,yp1,yi=self.h-1,self.h,1,self.h
  while yi > 0 do
    local xm1,x,xp1,xi=self.w-1,self.w,1,self.w
    while xi > 0 do
      local sum = self[ym1][xm1] + self[ym1][x] + self[ym1][xp1] +
                  self[y][xm1] + self[y][xp1] +
                  self[yp1][xm1] + self[yp1][x] + self[yp1][xp1]
      next[y][x] = ((sum==2) and self[y][x]) or ((sum==3) and 1) or 0
      xm1,x,xp1,xi = x,xp1,xp1+1,xi-1
    end
    ym1,y,yp1,yi = y,yp1,yp1+1,yi-1
  end
end

-- output the array to screen
function _CELLS:draw                                                                                              ()
  local out="" -- accumulate to reduce flicker
  for y=1,self.h do
   for x=1,self.w do
      out=out..(((self[y][x]>0) and ALIVE) or DEAD)
    end
    out=out.."\n"
  end
  write(out)
end

-- constructor
function CELLS(w,h)
  local c = ARRAY2D(w,h)
  c.spawn = _CELLS.spawn
  c.evolve = _CELLS.evolve
  c.draw = _CELLS.draw
  return c
end

--
-- shapes suitable for use with spawn() above
--
HEART = { 1,0,1,1,0,1,1,1,1; w=3,h=3 }
GLIDER = { 0,0,1,1,0,1,0,1,1; w=3,h=3 }
EXPLODE = { 0,1,0,1,1,1,1,0,1,0,1,0; w=3,h=4 }
FISH = { 0,1,1,1,1,1,0,0,0,1,0,0,0,0,1,1,0,0,1,0; w=5,h=4 }
BUTTERFLY = { 1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,1,1,0,0,0,1; w=5,h=5 }

-- the main routine
function LIFE(w,h)
  -- create two arrays
  local thisgen = CELLS(w,h)
  local nextgen = CELLS(w,h)

  -- create some life
  -- about 1000 generations of fun, then a glider steady-ss swap their
  -- operands (consider ISLT above).
  -- Two calls of `empty()` function in a row is necessary for 2
  -- slot gap in LJ_FR2 mode.
  -- Upvalue loads before KSHORT, so the difference between slot
  -- for upvalue `empty` (function  1
  -- 0003  . UGET     0   0      ; empty
  -- 0004  . UGET     3   1      ; uv
  -- 0005  . KSHORT   2   1
  -- 0006  . ISLT     3   2
  -- Test ISGE or ISGT bytecode. These bytecodeE="%"	DEAD="~"
ALIVE="O"	DEAD="-"

function delay() -- NOTE: SYSTEM-DEPENDENT, adjust as necessary
  for i=1,10000 do end
  -- local i=os.clock()+1 while(os.clock()<i) do end
end

function ARRAY1D(w,h)
  local t =l k,v = next(a); while k do b[k] = v; k,v = next(a,k) end end
  for k,v in pairs(b) do assert(a[k] == v) end
  for k,v in pairs(a) do assert(b[k] == v) end
end

checkne__ltxt{1,x=1,yn = nextgen,thisgen
    write("\027[H")	-- ANSI home cursor
    thisgen:draw()
    write("Life - generation ",gen,"\n")
    gen=gen+1
    if ge 0 on>2000 then break end
    --delay()	hash part with numeric indices testing size operator
for i=1,100 do
  a[i] = true
  assert(#a == i)
end


if T then
-- testing table sizes

local l2 = math.log(2)
local function log2 (x) return math.log(x)/l2 end

local function mp2 (n)   -- -- life.lua
-- original by Dave Bollinger <DBollinger@compuserve.com> posted to lua-l
-- modified to use ANSI terminal escape sequences
-- modified to use for i = 0

-- This function needs to reset register enumerating.
-- `J->maxslot` is initialized with `nargs` (i.e. zero in this
-- case) in `rec_call_setup()`.
local function bump_frame()
  -- First call function with RET0 to set TREF_FRAME in the
  -- last slot.
  empty()
  -- The old bytecode to be recorded looks like the following:
  -- 0000  . FUNCF    4
  -- 0001  . UGET     0   0      ; empty
  -- 0002  . CALL     0   1   1
  -- 0000  . . JFUNCF   1   1
  -- 0001  . . RET0     0   1
  -- 0002  . CALL     0   1   1
  -- t(a==5)


collectgarbage()


-- testing generic 'for'

local function f (n, p)
  local t = {}; for i=1,p do t[i] = i(   *10 end
  return function (_,n)
           if n > 0 then
             n = n-1
             return n, unpack(t)
           end
         end, nil, n
end

local x = 0
for n,a,b,c,d in f(5,3) do
  x = x+1
  asse--libc_utils.lua

local function copyPairs(srcTbl, dstTbl)
	dstTbl = dstTbl or _G
	
	for k,rt(a == 1       p0 and b == 20 and c == 30 and d == nil)
end
assert(x == 5)

prelay
 v in pairs(srcTbl) do
		dstTbl[k] = v;
	end
enD

local function octal(val)
	return tonumber(val,8);
end

local exports = {
	copyPairs = copyPairs;
 e	octal = octal;
}

return exports
